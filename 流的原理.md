今天跟大家分享的是node.js中的流（stream）。它的作用大家应该都在平常使用node的时候看到过，比如：

* gulp中的pipe就是流的一种方法，通过可写流和可读流的配合，达到不占用多余缓存的一种读写方式。
* express和koa中的res和req也是流，res是可写流，req是可读流，它们都是通过封装node中的net模块的socket（双工流，即可写、可读流）而来的。

## 何谓流？

* 流是一组有序的，有起点和终点的字节数据传输手段。
* 它不关心文件的整体内容，只关注是否从文件中读到了数据，以及读到数据之后的处理。
* 流是一个抽象接口，被Node中的很多对象所实现。比如HTTP服务器request和response对象都是流。
* 流被分为Readable（可读流）、Writable（可写流）、Duplex（双工流）、Transform（转换流）

## 流中的是什么？

* 二进制模式：每个分块都是buffer、string对象。
* 对象模式：流内部处理的是一系列普通对象。

## 可读流

> 可读流分为flowing和paused两种模式

### 参数

* path：读取的文件的路径
* option：
  * highWaterMark：水位线，一次可读的字节，一般默认是64k
  * flags：标识，打开文件要做的操作，默认是r
  * encoding：编码，默认是buffer
  * start：开始读取的索引的位置
  * end：结束读取的索引位置（包括结束位置）
  * autoClose：读取完毕是否关闭，默认为true

```javascript
let ReadStream = require('./ReadStream');
// 读取的时候默认读64k
let rs = new ReadStream('./a.txt', {
    highWaterMark: 2,	// 一次读的字节，默认64k
    flags: 'r',		// 标识，r为读，w为写
    autoClose: true,	// 默认读取完毕后自动关闭
    start: 0,	
    end: 5,			// 流是闭合区间包start，也包end，默认是读完
    encoding: 'utf8'	// 默认编码是buffer
})
```

### 方法

**data：切换到流动模式，可以流出数据**

```javascript
rs.on('data', function(data){
    console.log(data);
});
```

**open：流打开文件的时候会触发此监听**

```javascript
rs.on('open', function(){
    console.log('文件被打开');
});
```

**error：流出错的时候，监听错误信息**

```javascript
rs.on('error', function(err){
    console.log(err);
});
```

**end：流读取完成，触发end**

```javascript
rs.on('end', function(err){
    console.log('读取完成');
});
```

**close：关闭流，触发**

```javascript
rs.on('close', function(err){
    console.log('关闭');
});
```

**pause：暂停流（改变流的flowing，不读取数据了）；resume：恢复流（改变流的flowing，继续读取数据）**

```javascript
// 流通过一次后，停止流动，过了2s后再动
rs.on('data', function(data){
    rs.pause();
    console.log(data);
});
setTimeout(function(){
    rs.resume();
}, 2000);
```

**fs.read()：可读流底层调用的就是这个方法，最原生的读方法**

```javascript
// fd文件描述符，一般通过fs.open中获取
// buffer是读取后的数据放入的缓存目标
// 0，从buffer的0位置开始放入
// BUFFER_SIZE，每次放BUFFER_SIZE这么长的长度
// index，每次从文件的index的位置开始读
// bytesRead,真实读到的个数
fs.read(fd, buffer, 0, BUFFER_SIZE, index, function(err, bytesRead){
    
});
```



