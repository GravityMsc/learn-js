## 一、跨域及常见解决办法

### 概述

因为浏览器出于安全考虑，有了同源策略,这样就导致只要协议、域名、端口有任何一个不同，都被当作是不同的域。也就是说，如果协议、域名或者端口有一个不同就是跨域，Ajax 请求就会失败，DOM和JS对象无法获得，Cookie、LocalStorage和IndexDB无法获取。

### 常见跨域的解决办法

#### JSONP

JSONP 的原理很简单，就是利用 `<script>` 标签没有跨域限制的漏洞。通过 `<script>` 标签指向一个需要访问的地址并提供一个回调函数来接收数据当需要通讯时。

```html
<script src="http://domain/api?param1=a&param2=b&callback=jsonp"></script>
<script>
    function jsonp(data) {
    	console.log(data)
	}
</script>
```

JSONP 使用简单且兼容性不错，但是**只限于 get 请求。**

在开发中可能会遇到多个 JSONP 请求的回调函数名是相同的，这时候就需要自己封装一个 JSONP，以下是简单实现

```javascript
function jsonp(url, jsonpCallback, success) {
  let script = document.createElement('script')
  script.src = url
  script.async = true
  script.type = 'text/javascript'
  window[jsonpCallback] = function(data) {
    success && success(data)
  }
  document.body.appendChild(script)
}
jsonp('http://xxx', 'callback', function(value) {
  console.log(value)
})
```

#### CORS

CORS（Cross-Origin ResourceSharing）跨域资源共享，**定义了必须在访问跨域资源时，浏览器与服务器应该如何沟通。**

CORS背后的基本思想就是**使用自定义的HTTP头部让浏览器与服务器进行沟通，从而决定请求或响应是应该成功还是失败。** 目前，所有浏览器都支持该功能，**IE浏览器不能低于IE10。** 因为需要通过 `XDomainRequest` 来实现。

**整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。**

因此，实现CORS通信的关键是服务器。**只要服务器实现了CORS接口，就可以跨源通信。**

服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。该属性表示哪些域名可以访问资源，如果设置通配符则表示所有网站都可以访问资源。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。

#### postMessage

这是由H5提出来的的API，IE8以上支持这个功能。window.postMessage() 方法可以安全地实现跨源通信。通常，对于两个不同页面的脚本，只有当执行它们的页面位于具有相同的协议（通常为https），端口号（443为https的默认值），以及主机  (两个页面的模数 Document.domain设置为相同的值) 时，这两个脚本才能相互通信。window.postMessage() 方法提供了一种受控机制来规避此限制，只要正确的使用，这种方法就很安全。

window.postMessage() 方法被调用时，会在所有页面脚本执行完毕之后,向目标窗口派发一个  MessageEvent 消息。

该MessageEvent消息有四个属性需要注意：

- message 属性表示该message 的类型；
- data 属性为 window.postMessage 的第一个参数；
- origin 属性表示调用window.postMessage() 方法时调用页面的当前状态；
- source 属性记录调用 window.postMessage() 方法的窗口信息。

**语法**

```
otherWindow.postMessage(message, targetOrigin);
```

- otherWindow:指目标窗口，也就是给哪个window发消息，是 window.frames 属性的成员或者由 window.open 方法创建的窗口
- message:   是要发送的消息，类型为 String、Object (IE8、9 不支持)
- targetOrigin:   是限定消息接收范围，不限制请使用 '*

**例子:**

A页面通过postMessage方法发送消息：

```javascript
window.onload = function() {  
    var ifr = document.getElementById('ifr');  
    var targetOrigin = "http://www.google.com";  
    ifr.contentWindow.postMessage('hello world!', targetOrigin);  
};
```

B页面通过message事件监听并接受消息:

```javascript
var onmessage = function (event) {  
  var data = event.data;//消息  
  var origin = event.origin;//消息来源地址  
  var source = event.source;//源Window对象  
  if(origin=="http://www.baidu.com"){  
console.log(data);//hello world!  
  }  
};  
if (typeof window.addEventListener != 'undefined') {  
  window.addEventListener('message', onmessage, false);  
} else if (typeof window.attachEvent != 'undefined') {  
  //for ie  
  window.attachEvent('onmessage', onmessage);  
}
```

####nginx代理跨域

**跨域原理：** 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。

**实现思路：** 通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。

nginx具体配置：

```bash
#proxy服务器
server {
    listen       81;
    server_name  www.domain1.com;

    location / {
        proxy_pass   http://www.domain2.com:8080;  #反向代理
        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名
        index  index.html index.htm;

        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用
        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*
        add_header Access-Control-Allow-Credentials true;
    }
}
```

## 二、前端本地存储

### cookie

**作用**

cookie是纯文本。存储数据，当用户访问了某个网站（网页）的时候，我们就可以通过cookie来向访问者电脑上存储数据，或者某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。

**如何工作**

当网页要发送http请求的时候，浏览器会先检查是否有相应的cookie，有则自动添加在request header中的cookie字段中。这是浏览器自动帮我们做的，而且每一次http请求浏览器都会自动帮我们做。这个特点很重要，因为这关系到“什么样的数据适合存储在cookie中”。

存储在cookie中的数据，每次都会被浏览器自动放在http请求中，如果这些数据并不是每个请求都需要发给服务端的数据，浏览器这设置自动处理无疑增加了网络开销；但如果这些数据是每个请求都需要发给服务端的数据（比如身份认证信息），浏览器这设置自动处理就大大免去了重复添加操作。所以对于那种设置“每次请求都要携带的信息（最典型的就是身份认证信息）”就特别适合放在cookie中，其他类型的数据就不适合了。

**特征**

1. 不同的浏览器存放的cookie位置不一样，也是不能通用的。
2. cookie的存储是以域名形式进行区分的，不同的域下面存储的cookie是独立的。
3. 我们可以设置cookie生效的域（当前设置cookie所在域的子域），也就是说，我们能够操作的cookie是当前域已经当前域下面的所有子域。
4. 一个域名下存放的cookie的个数是有限制的，不同的浏览器存放的个数不一样，一般为20个。
5. 每个cookie存放的内容大小也是有限制的，不同的浏览器存放大小不一样，一般为4KB。
6. cookie也可以设置过期的时间，默认是会话结束的时候，当时间到期自动销毁。

**cookie的用途**

* 会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）
* 个性化设置（如用户自定义设置、主题等）
* 浏览器行为跟踪（如跟踪分析用户行为等）

**设置**

* 客户端设置：

  ```javascript
  document.cookie = '名字=值';
  document.cookie = 'username=cfangxu; domain=baike.baidu.com'    //并且设置了生效域
  //在设置这些属性时，属性之间由一个分号和一个空格隔开。
  
  //当我们需要设置多个cookie时
  document.cookie = "name=Jonh";
  document.cookie = "age=12";
  document.cookie = "class=111";
  ```

  注意：客户端可以设置cookie下列选项：expires（过期时间）、domain（服务器域名）、path（域名下的哪些路径可以接受cookie）、secure（有条件：只有https协议的网页中，客户端设置secure类型的cookie才能成功），但无法设置HttpOnly选项。

* 服务端设置

  不管你是请求一个资源文件（如html/js/css/图片），还是发送一个ajax请求，服务端都会返回response。而response header中有一项叫set-cookie，是服务端专门用来设置cookie的。

  ```javascript
  Set-Cookie  //消息头是一个字符串，其格式如下（中括号中的部分是可选的）：
  Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]
  ```

  注意：**一个set-Cookie字段只能设置一个cookie，当你要想设置多个 cookie，需要添加同样多的set-Cookie字段。**  服务端可以设置cookie 的所有选项：expires、domain、path、secure、**HttpOnly**  通过 Set-Cookie 指定的这些可选项只会在浏览器端使用，而不会被发送至服务器端。

**读取cookie**

我们通过document.cookie老获取当前网站下的cookie的时候，得到的字符串形式的值，它包含了当前网站下所有的cookie（为了避免跨域脚本（xss）攻击，这个方法只能获取非HttpOnly类型的cookie）。它会把所有的cookie通过一个分号+空格的形式串联起来，例如username=chenfangxu; job=coding

**修改cookie**

要想修改一个cookie，只需套重新赋值就行，旧的值会被新的值覆盖。但要注意一点，在设置新cookie时，path/domain这几个选项一定要与旧cookie保持一样。否则不会修改旧值，而是添加了一个新的cookie。

**删除cookie**

把要删除的cookie的**过期时间设置成已过去的时间**,path/domain/这几个选项一定要旧cookie 保持一样。

**注意**

* cookie虽然是个字符串，但这个字符串中逗号、分号、空格被当作了特殊符号。所以当cookie的key和value中含有这3个特殊字符时，需要对其进行额外编码，一般会用escape进行编码，读取时用unescape进行解码；当然也可以用`encodeURIComponent/decodeURIComponent`或者`encodeURI/decodeURI`（[三者的区别可以参考这篇文章](<http://www.cnblogs.com/season-huang/p/3439277.html>)）。
* 什么时候cookie会被覆盖：name/domain/path这3个字段都相同的时候。

####expires

`expires`选项用来设置“cookie 什么时间内有效”。`**expires`其实是`cookie`失效日期**，`expires`必须是 `GMT` 格式的时间（可以通过 **new Date().toGMTString()或者new Date().toUTCString() 来获得** ）。

如`expires=Thu, 25 Feb 2016 04:18:00 GMT`表示`cookie`讲在2016年2月25日4:18分之后失效，对于失效的`cookie`浏览器会清空。如果没有设置该选项，则**默认有效期为session，即会话cookie。这种cookie在浏览器关闭后就没有了。**

> ```
> expires` 是 http/1.0协议中的选项，在新的http/1.1协议中`expires`已经由 `max-age` 选项代替，两者的作用都是限制cookie 的有效时间。`expires`的值是一个时间点（`cookie失效时刻= expires`），而`max-age` 的值是一个以`秒`为单位时间段（`cookie失效时刻= 创建时刻+ max-age`）。 另外，`max-age` 的默认值是 `-1`(即有效期为 `session` )；若`max-age`有三种可能值：负数、0、正数。负数：有效期`session`；`0`：删除`cookie`；正数：有效期为`创建时刻+ max-age
> ```

####domain 和 path

`domain`是域名，`path`是路径，两者加起来就构成了 URL，`domain`和`path`一起来限制 cookie 能被哪些 URL 访问。

一句话概括：某cookie的 `domain`为“[baidu.com](https://link.juejin.im?target=http%3A%2F%2Fbaidu.com)”, `path`为“/ ”，若请求的URL(URL 可以是js/html/img/css资源请求，**但不包括 XHR 请求**)的域名是“[baidu.com](https://link.juejin.im?target=http%3A%2F%2Fbaidu.com)”或其子域如“[api.baidu.com](https://link.juejin.im?target=http%3A%2F%2Fapi.baidu.com)”、“[dev.api.baidu.com](https://link.juejin.im?target=http%3A%2F%2Fdev.api.baidu.com)”，且 URL 的路径是“/ ”或子路径“/home”、“/home/login”，则浏览器会将此 cookie 添加到该请求的 cookie 头部中。

所以`domain`和`path`2个选项共同决定了`cookie`何时被浏览器自动添加到请求头部中发送出去。如果没有设置这两个选项，则会使用默认值。**domain的默认值为设置该cookie的网页所在的域名，path默认值为设置该cookie的网页所在的目录。**

####secure

通常 cookie 信息都是使用HTTP连接传递数据，这种传递方式很容易被查看，所以 cookie 存储的信息容易被窃取。假如 cookie 中所传递的内容比较重要，那么就要求使用加密的数据传输。

secure选项用来设置cookie只在确保安全的请求中才会发送。当请求是HTTPS或者其他安全协议时，包含 secure 选项的 cookie 才能被发送至服务器。

```
document.cookie = "username=cfangxu; secure"
```

**把cookie设置为secure，只保证 cookie 与服务器之间的数据传输过程加密，而保存在本地的 cookie文件并不加密。就算设置了secure 属性也并不代表他人不能看到你机器本地保存的 cookie 信息。** 机密且敏感的信息绝不应该在 cookie 中存储或传输，因为 cookie 的整个机制原本都是不安全的

**注意：如果想在客户端即网页中通过 js 去设置secure类型的 cookie，必须保证网页是https协议的。在http协议的网页中是无法设置secure类型cookie的。**

####httpOnly

这个选项用来设置cookie是否能通过 js 去访问。默认情况下，cookie不会带httpOnly选项(即为空)，所以默认情况下，客户端是可以通过js代码去访问（包括读取、修改、删除等）这个cookie的。当cookie带httpOnly选项时，客户端则无法通过js代码去访问（包括读取、修改、删除等）这个cookie。

**在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。**

——**httpOnly与安全**

从上面介绍中，大家是否会有这样的疑问：为什么我们要限制客户端去访问`cookie`？其实这样做是为了保障安全。

试想：如果任何 cookie 都能被客户端通过`document.cookie`获取会发生什么可怕的事情。当我们的网页遭受了 XSS 攻击，有一段恶意的`script`脚本插到了网页中。这段`script`脚本做的事情是：通过`document.cookie`读取了用户身份验证相关的 cookie，并将这些 cookie 发送到了攻击者的服务器。攻击者轻而易举就拿到了用户身份验证信息，于是就可以摇摇大摆地冒充此用户访问你的服务器了（因为攻击者有合法的用户身份验证信息，所以会通过你服务器的验证）。

####第三方cookie

通常cookie的域和浏览器地址的域匹配，这被称为第一方cookie。那么第三方cookie就是cookie的域和地址栏中的域不匹配，这种cookie通常被用在第三方广告网站。为了跟踪用户的浏览记录，并且根据收集的用户的浏览习惯，给用户推送相关的广告。  关于第三方cookie和cookie的安全问题可以查看[这篇文章](https://link.juejin.im?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FoOGIuJCplPVW3BuIx9tNQg)

- **cookie推荐资源**
  - [聊一聊 cookie](https://link.juejin.im?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000004556040)
  - [HTTP cookies 详解](https://link.juejin.im?target=http%3A%2F%2Fbubkoo.com%2F2014%2F04%2F21%2Fhttp-cookies-explained%2F)

####session和cookie区别

- session保存在服务器，cookie保存在客户端
- session中保存的时对象，cookie保存的是字符串
- session不能区分路径，同一个用户访问一个网站期间，所有的session在任何一个地方都可以访问
- cookie如果设置路径，则在某些地方不能访问
- session需要借助cookie才能正常工作，如果禁用cookie,session则失效
- 客户端会在发送请求的时候，自动将本地存活的cookie封装在信息头发送给服务器 复制代码

####session和cookie应用场景

- session上下文机制，针对每一个用户，通过sessionid来区分不同客户
- session是以cookie或url重写为基础的，默认使用cookie实现，系统会创造一个名为jsessionid的输出cookie
- 重要状态走session,不重要走cookie,登陆信息用session，购物车用cookie

###localStorage（本地存储）

HTML5新方法，仅IE8及以上浏览器兼容。

**特点:**

- 生命周期：持久化的本地存储，**除非主动删除数据，否则数据是永远不会过期的。**
- 存储的信息**在同一域中是共享的**。
- **当本页操作（新增、修改、删除）了localStorage的时候，本页面不会触发storage事件,但是别的页面会触发storage事件。**
- 大小：据说是5M（跟浏览器厂商有关系）
- 在非IE下的浏览中可以本地打开。IE浏览器要在服务器中打开。
- localStorage本质上是对字符串的读取，如果存储内容多的话会消耗内存空间，会导致页面变卡
- **localStorage受同源策略的限制**

**设置**

```
localStorage.setItem('username','cfangxu');
```

**获取**

```
localStorage.getItem('username')`  也可以获取键名  `localStorage.key(0) #获取第一个键名
```

**删除**

```
localStorage.removeItem('username')`  也可以一次性清除所有存储  `localStorage.clear()
```

**storage事件**

当storage发生改变的时候触发。

**注意：** 当前页面对storage的操作会触发其他页面的storage事件  事件的回调函数中有一个参数event,是一个StorageEvent对象，提供了一些实用的属性,如下表：

| Property | Type   | Description                                                  |
| -------- | ------ | ------------------------------------------------------------ |
| key      | String | The named key that was added, removed, or moddified          |
| oldValue | Any    | The previous value(now overwritten), or null if a new item was added |
| newValue | Any    | The new value, or null if an item was added                  |
| url/uri  | String | The page that called the method that triggered this change   |

**补充:**
 **js跨页面触发事件，利用storage监听事件** 触发storage事件的条件：

- 同一浏览器打开了两个同源页面
- 其中一个页面修改了localStorage
- 另一个网页注册了这个事件

####sessionStorage

其实跟localStorage差不多，也是本地存储，会话本地存储

**特点**

- 用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。也就是说只要这个浏览器窗口没有关闭，即使刷新页面或进入同源另一页面，数据仍然存在。关闭窗口后，sessionStorage即被销毁，或者**在新窗口打开同源的另一个页面，sessionStorage也是没有的。**

####cookie、localStorage、sessionStorage区别

- 相同：在本地（浏览器端）存储数据
- 不同： 
  - localStorage只要在相同的协议、相同的主机名、相同的端口下，就能读取/修改到同一份localStorage数据。
  - sessionStorage比localStorage更严苛一点，除了协议、主机名、端口外，**还要求在同一窗口（也就是浏览器的标签页）下。**
  - **localStorage是永久存储，除非手动删除。**
  - **sessionStorage当会话结束（当前页面关闭的时候，自动销毁）**
  - **cookie的数据会在每一次发送http请求的时候，同时发送给服务器而localStorage、sessionStorage不会。**

## 三、渲染机制

### 渲染步骤

浏览器的渲染机制一般分为以下几个步骤:

- 1. 处理 HTML 并构建 DOM 树。
- 1. 处理 CSS 构建 CSSOM 树。
- 1. 将 DOM 与 CSSOM 合并成一个渲染树。
- 1. 根据渲染树来布局，计算每个节点的位置。
- 1. 调用 GPU 绘制，合成图层，显示在屏幕上。

**注意:**

- 在构建 CSSOM 树时，会阻塞渲染，直至 CSSOM 树构建完成。并且**构建 CSSOM 树是一个十分消耗性能的过程**，所以应该尽量保证层级扁平，减少过度层叠，**越是具体的 CSS 选择器，执行速度越慢**。
- **当 HTML 解析到 script 标签时，会暂停构建 DOM，** 完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件。并且 CSS 也会影响 JS 的执行，只有当解析完样式表才会执行 JS，所以也可以认为这种情况下，CSS 也会暂停构建 DOM。

### Load 和 DOMContentLoaded 区别

- Load 事件触发代表页面中的 DOM，CSS，JS，图片已经全部加载完毕。
- DOMContentLoaded 事件触发代表初始的 **HTML 被完全加载和解析，不需要等待 CSS，JS，图片加载。**

### 图层

一般来说，**可以把普通文档流看成一个图层**。特定的属性可以生成一个新的图层。**不同的图层渲染互不影响**，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。**但也不能生成过多的图层，会引起反作用。**

通过以下几个常用属性可以生成新图层

- 3D 变换：`translate3d`、`translateZ`
- `will-change`
- `video`、`iframe` 标签
- 通过动画实现的 `opacity` 动画转换
- `position: fixed`

###重绘（Repaint）和回流（Reflow）

####概念

重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大。

- **重绘是** 当节点需要**更改外观而不会影响布局**的，比如改变 color、background-color、visibility等就叫称为重绘
- **回流是 布局或者几何属性需要改变** 就称为回流。

注意: **回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流。**

####会导致回流的操作：

- 页面首次渲染
- 浏览器窗口大小发生改变
- 元素尺寸或位置发生改变
- 元素内容变化（文字数量或图片大小等等）
- 元素字体大小变化
- 添加或者删除**可见**的`DOM`元素
- 激活`CSS`伪类（例如：`:hover`）
- 查询某些属性或调用某些方法

一些常用且会导致回流的属性和方法：

- `clientWidth`、`clientHeight`、`clientTop`、`clientLeft`
- `offsetWidth`、`offsetHeight`、`offsetTop`、`offsetLeft`
- `scrollWidth`、`scrollHeight`、`scrollTop`、`scrollLeft`
- `scrollIntoView()`、`scrollIntoViewIfNeeded()`
- `getComputedStyle()`
- `getBoundingClientRect()`
- `scrollTo()`

####重绘和回流与Event loop关系

很多人不知道的是，重绘和回流其实和 Event loop 有关。

1. 当 Event loop 执行完 Microtasks 后，会判断 document 是否需要更新。因为浏览器是 60Hz 的刷新率，每 16ms 才会更新一次。
2. 然后判断是否有 `resize` 或者 `scroll` ，有的话会去触发事件，所以 `resize` 和 `scroll` 事件也是至少 16ms 才会触发一次，并且自带节流功能。
3. 判断是否触发了 media query
4. 更新动画并且发送事件
5. 判断是否有全屏操作事件
6. 执行 `requestAnimationFrame` 回调
7. 执行 `IntersectionObserver` 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好
8. 更新界面
9. 以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 `requestIdleCallback` 回调。

####减少重绘和回流

- 使用 `translate` 替代 `top`

- 使用 `visibility` 替换 `display: none` ，因为前者只会引起重绘，后者会引发回流（改变了布局）
- 把 DOM 离线后修改，比如：先把 DOM 给 `display:none` (有一次 Reflow)，然后你修改 100 次，然后再把它显示出来
- 不要把 DOM 结点的属性值放在一个循环里当成循环里的变量
- 不要使用 table 布局，可能很小的一个小改动会造成整个 table 的重新布局
- 动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 `requestAnimationFrame`
- CSS 选择符从右往左匹配查找，避免 DOM 深度过深
- 将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 `video` 标签，浏览器会自动将该节点变为图层。

**CSS**

- 避免使用`table`布局。
- 尽可能在`DOM`树的最末端改变`class`。
- 避免设置多层内联样式。
- 将动画效果应用到`position`属性为`absolute`或`fixed`的元素上。
- 避免使用`CSS`表达式（例如：`calc()`）。

**JavaScript**

- 避免频繁操作样式，最好一次性重写`style`属性，或者将样式列表定义为`class`并一次性更改`class`属性。
- 避免频繁操作`DOM`，创建一个`documentFragment`，在它上面应用所有`DOM操作`，最后再把它添加到文档中。
- 也可以先为元素设置`display: none`，操作结束后再把它显示出来。因为在`display`属性为`none`的元素上进行的`DOM`操作不会引发回流和重绘。
- 避免频繁读取会引发回流/重绘的属性，如果确实需要多次使用，就用一个变量缓存起来。
- 对具有复杂动画的元素使用绝对定位，使它脱离文档流，否则会引起父元素及后续元素频繁回流。

## 四、浏览器缓存概述

### 什么是缓存

缓存(和我之前文章所说的前端存储是不一样的!注意区分):
 是一种保存资源副本并在下次请求时直接使用该副本的技术。那么浏览器缓存就是浏览器请求网站留下的资源副本。

当 web 缓存发现请求的资源已经被存储，它会拦截请求，返回该资源的拷贝，而不会去源服务器重新下载。

### 缓存的好处

- 缓解服务器压力(不用每次去请求资源)；
- 提升性能(打开本地资源速度当然比请求回来再打开要快得多)；
- 减少带宽消耗；

### 缓存的分类

缓存在宏观上可以分成两类：

- 私有缓存: 只能用于单独用户,最常见的就是浏览器缓存,也是本片重点讲解的.
- 共享缓存: 够被多个用户使用的缓存,也就是那些能被各级代理的缓存.

###浏览器的缓存策略

浏览器对于缓存的处理是根据第一次请求资源时返回的**响应头**来确定的。

根据响应头,浏览器缓存策略一般分为三种：**强缓存**,**协商缓存**和**启发式缓存**。

### 浏览器常见字段和指令

在讲强缓存和协商缓存之前先提前了解以下这几个字段和指令,便于后面理解:

1. expires: 告知客户端资源缓存失效的绝对时间
2. last-modified: 资源最后一次修改的时间
3. Etag: 文件的特殊标识
4. cache-control:告诉客户端或是服务器如何处理缓存。
5. private: cache-control里的响应指令.表示客户端可以缓存
6. public: cache-control里的响应指令.表示客户端和代理服务器都可缓存.如果没有明确指定private，则默认为public。
7. no-cache: cache-control里的指令.表示需要可以缓存，但每次用应该去向服务器验证缓存是否可用
8. no-store: cache-control字段里的指令.表示所有内容都不会缓存，强制缓存，对比缓存都不会触发.
9. max-age=xxx: cache-control字段里的指令.表示缓存的内容将在 xxx 秒后失效

### **强缓存**

强缓存简单理解就是:给浏览器缓存设置过期时间，超过这个时间之后缓存就是过期,浏览器需要重新请求。

**强缓存主要是通过http请求头中的Cache-Control和Expires两个字段控制**。

#### expires

expires是一个HTTP/1.0的字段,它给浏览器设置了一个绝对时间，当浏览器时间超过这个绝对时间之后，重新向服务器发送请求。

**用法:**

它描述的是一个**绝对时间,用GMT格式的字符串表示**

```
Expires: Wed Feb 20 2019 11:25:41 GMT
复制代码
```

也可以在html文件里直接使用:

```
<meta http-equiv="expires" content="Wed Feb 20 2019 11:25:41 GMT">
复制代码
```

**弊端:**

- Expires返回的是服务器的时间，但判断的时候用的却是客户端的时间，这就导致Expires很被动，因为用户有可能改变客户端的时间，导致缓存时间判断出错，这也是引入Cache-Control:max-age指令的原因之一。

#### cache-control: max-age

为了解决expires存在的问题，Http1.1版本中提出了cache-control:max-age，该字段与expires的缓存思路相同，都是设置了一个过期时间，不同的是max-age设置的是**相对缓存时间开始往后的多少秒，因此不再受日期不准确情况的影响。**

**优先级:**
 在优先级上:`max-age>Expires`。当两者同时出现在响应头时,Expires将被max-age覆盖.

**用法:**

```
Cache-control: max-age=666
复制代码
```

表示资源会在 666 秒后过期，需要再次请求。

#### 强缓存在浏览器上的表现

- Firefox浏览器对强缓存表现为一个灰色的200状态码。
- Chrome浏览器状态码表现为:`200 (from disk cache)或是200 OK (from memory cache)`

说明:Chrome会根据本地内存的使用率来决定缓存存放在哪，如果内存使用率很高，放在磁盘里面，磁盘的使用率很高会暂时放在内存里面。这就可以比较合理的解释了为什么同一个资源有时是from memory cache有时是from disk cache的问题了。

但是强制缓存存在一个问题，该缓存方式优先级高，如果在过期时间内缓存的资源在服务器上更新了，客服端不能及时获取最新的资源。这时怎么办?于是就有了协商缓存.

### **协商缓存**

协商缓存解决了无法及时获取更新资源的问题。它利用下面会讲到的两组字段,对资源做标识.然后由服务器做分析，如果资源未更新，则返回304状态码.那么浏览器则会从缓存中读取资源，否则重新请求资源。

**协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。**

#### Last-Modified与If-Modified-Since

- 1,浏览器第一次向服务器请求资源，服务器会在返回这个资源的同时，**在response的header加上Last-Modified的header**,这个header表示这个资源在服务器上的最后修改时间：`Last-Modified: Wed Feb 20 2019 14:08:32 GMT`
- 2,浏览器之后再向服务器请求这个资源时，**在request的header上加上If-Modified-Since的header**，这个header的值就是上一次请求时返回的Last-Modified的值：`Last-Modified: Wed Feb 20 2019 14:08:32 GMT`
- 3,服务器再次收到资源请求时，**根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化**，如果没有变化则返回304 Not Modified，但是**不会返回资源内容**；如果有变化,返回200，就正常返回资源内容。
  - **当服务器返回304 Not Modified的响应时，response的header中不会再添加Last-Modified的header**，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header.
- 4,浏览器收到304的响应后，就会从缓存中加载资源。
- 5,浏览器收到200的响应后，则从服务器加载新资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。

**弊端:**
 【Last-Modified，If-Modified-Since】都是根据服务器时间返回的header，一般来说，在没有调整服务器时间和篡改客户端缓存的情况下，这两个header配合起来管理协商缓存是非常可靠的，但是**它们是以秒为单位进行更新，如果小于该单位高频进行更新的话，则不适合采用该方法。** 这时候协商缓就不那么的可靠了。所以就有了另外一对header来管理协商缓存，这对header就是【ETag、If-None-Match】。

#### ETag与If-None-Match

- 1,浏览器第一次跟服务器请求一个资源，**服务器在返回这个资源的同时，在response的header加上ETag的header**，这个header是服务器**根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串**，`ETag: shotcat-66666`只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题.
- 2,浏览器再次跟服务器请求这个资源时，**在request的header上加上If-None-Match的header**，这个header的值就是上一次请求时返回的ETag的值`If-None-Match: shotcat-66666`.
- 3,服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，则返回200,并正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，**由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化**
- 4,浏览器收到304的响应后，就会从缓存中加载资源。
- 5,浏览器收到200的响应后，则从服务器加载新资源时，ETag在重新加载的时候会被更新，下次请求时，If-None-Match会启用上次返回的ETag值。

Etag和Last-Modified非常相似，都是用来判断一个参数，从而决定是否启用缓存。但是ETag相对于Last-Modified也有其优势，**可以更加准确的判断文件内容是否被修改，** 从而在实际操作中实用程度也更高,但缺点也很明显,**由于需要对资源进行生成标识，性能方面就势必有所牺牲**。

**优先级:**
 **ETag与If-None-Match > Last-Modified与If-Modified-Since,** 同时存在时, 前者覆盖后者.

### 启发式缓存

我跟我们的请求头中确定缓存过期时间的字段一个都没有.例如:

```
Age:23146
Cache-Control: public
Date:Tue, 28 Nov 2017 12:26:41 GMT
Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT
Vary:Accept-Encoding
复制代码
```

此时则会默认触发浏览器启发式缓存:
 **浏览器会根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。**

### 缓存的优先级

在缓存策略上:强缓存>协商缓存>启发式缓存

进一步分析可得出,以下优先级：
 Cache-Control > Expires > ETag > Last-Modified

#### **非常注意**

其他所有教程都是告诉你浏览器肯定是先检查强缓存,再检查协商缓存!但实际它们都忽略了一点.其实浏览器是**先检查Cache-Control,如果为no-store.则浏览器 所有内容都不会缓存，强制缓存，协商缓存统统都不会触发!!!**

#### 补充:Pragma

它是HTTP/1.0里面的一个字段，在http1.1已被抛弃，使用Cache-Control替代.但为了做http协议的向下兼容，很多网站依旧会带上这个字段但优先级很高.

测试发现，Chrome和Firefox中Pragma的优先级高于Cache-Control和Expires.

一般可能会这么用：`<meta http-equiv="Pragma" content="no-cache">`

服务端响应添加'Pragma': 'no-cache'，浏览器表现行为和强制刷新类似。

####补充: Cache-Control

通过cache-control的指令可以控制告诉客户端或是服务器如何处理缓存。这也是11个字段中指令最多的一个，也是经常被用到的.

**请求指令**：

| 指令            | 参数               | 说明                              |
| --------------- | ------------------ | --------------------------------- |
| no-cache        | 无                 | 强制源服务器再次验证              |
| no-store        | 无                 | 不缓存请求或是响应的任何内容      |
| max-age=[秒]    | 缓存时长，单位是秒 | 缓存的时长，也是响应的最大的Age值 |
| min-fresh=[秒]  | 必需               | 期望在指定时间内响应仍然有效      |
| no-transform    | 无                 | 代理不可更改媒体类型              |
| only-if-cached  | 无                 | 从缓存获取                        |
| cache-extension | -                  | 新的指令标记(token)               |

**响应指令**：

| 指令             | 参数               | 说明                                           |
| ---------------- | ------------------ | ---------------------------------------------- |
| public           | 无                 | 任意一方都能缓存该资源(客户端、代理服务器等)   |
| private          | 可省略             | 只能特定用户缓存该资源                         |
| no-cache         | 可省略             | 缓存前必须先确认其有效性                       |
| no-store         | 无                 | 不缓存请求或响应的任何内容                     |
| no-transform     | 无                 | 代理不可更改媒体类型                           |
| must-revalidate  | 无                 | 可缓存但必须再向源服务器进确认                 |
| proxy-revalidate | 无                 | 要求中间缓存服务器对缓存的响应有效性再进行确认 |
| max-age=[秒]     | 缓存时长，单位是秒 | 缓存的时长，也是响应的最大的Age值              |
| s-maxage=[秒]    | 必需               | 公共缓存服务器响应的最大Age值                  |
| cache-extension  | -                  | 新指令标记(token                               |

请注意no-cache指令很多人误以为是不缓存，这是不准确的，**no-cache的意思是可以缓存，但每次用应该去想服务器验证缓存是否可用。no-store才是不缓存内容。** 另外部分指令也可以组合使用，比如：

```
Cache-Control: max-age=100, must-revalidate, public
复制代码
复制代码
```

上面指令的意思是缓存的有效时间为100秒，之后访问需要向源服务器发送请求验证，此缓存可被代理服务器和客户端缓存。

###浏览器缓存判断流程



![img](https://user-gold-cdn.xitu.io/2019/2/20/16909f4e7d100543?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

###HTTP中和缓存相关的首部字段

HTTP报文,主要由以下两部分构成：

1. **首部(header)**：包含了很多字段，比如：cookie、缓存、报文大小、报文格式等等）；
2. **主体(body)**：HTTP请求真正要传输的部分，比如：一个HTML文档，一个js文件；

以上我们知道浏览器对于缓存的处理过程，也简单的提到了几个相关的字段。🤧接下来我们具体看下这几个字段：

####1. 通用首部字段

| 字段名称      | 说明                                                |
| ------------- | --------------------------------------------------- |
| Cache-Control | 控制缓存具体的行为                                  |
| Pragma        | HTTP1.0时的遗留字段，当值为"no-cache"时强制验证缓存 |
| Date          | 创建报文的日期时间(启发式缓存阶段会用到这个字段)    |

####2. 响应首部字段

| 字段名称 | 说明                                                      |
| -------- | --------------------------------------------------------- |
| ETag     | 服务器生成资源的唯一标识                                  |
| Vary     | 代理服务器缓存的管理信息                                  |
| Age      | 资源在缓存代理中存贮的时长(取决于max-age和s-maxage的大小) |

####3. 请求首部字段

| 字段名称            | 说明                                                         |
| ------------------- | ------------------------------------------------------------ |
| If-Match            | 条件请求，携带上一次请求中资源的ETag，服务器根据这个字段判断文件是否有新的修改 |
| If-None-Match       | 和If-Match作用相反，服务器根据这个字段判断文件是否有新的修改 |
| If-Modified-Since   | 比较资源前后两次访问最后的修改时间是否一致                   |
| If-Unmodified-Since | 比较资源前后两次访问最后的修改时间是否一致                   |

####4. 实体首部字段

| 字段名称      | 说明                             |
| ------------- | -------------------------------- |
| Expires       | 告知客户端资源缓存失效的绝对时间 |
| Last-Modified | 资源最后一次修改的时间           |

###用户操作行为对缓存的影响

| 操作           | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| 打开新窗口     | 如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器,例如：Cache-control: max-age=5 表示当访问此网页后的5秒内不会去再次访问服务器. |
| 在地址栏回车   | 如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。 |
| 按后退按扭     | 如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问. |
| 按刷新按扭     | 无论为何值,都会重复访问.（可能返回状态码：200、304，这个不同浏览器处理是不一样的，FireFox正常，Chrome则会启用缓存(200 from cache)） |
| 按强制刷新按钮 | 当做首次进入重新请求(返回状态码200)                          |

如果想在浏览器点击“刷新”按钮的时候不让浏览器去发新的验证请求呢？办法找到一个，知乎上面一个回答，在页面加载完毕后通过脚本动态地添加资源：

```
$(window).load(function() {
  	var bg='http://img.infinitynewtab.com/wallpaper/100.jpg';
  	setTimeout(function() {
    	$('#bgOut').css('background-image', 'url('+bg+')');
  	},0);
});
复制代码
```

###选择合适的缓存策略

对于大部分的场景都可以使用强缓存配合协商缓存解决，但是在一些特殊的地方可能需要选择特殊的缓存策略

- 对于某些不需要缓存的资源，可以使用 `Cache-control: no-store` ，表示该资源不需要缓存
- 对于频繁变动的资源，可以使用 `Cache-Control: no-cache` 并配合 `ETag` 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新。
- 对于代码文件来说，通常使用 `Cache-Control: max-age=31536000` 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件。

## 五、XSS攻击

### 什么是 XSS

Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种**代码注入攻击**。攻击者通过在目标网站上注入恶意脚本，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

所以,网页上哪些部分会引起XSS攻击?简单来说,任何可以输入的地方都有可能引起,包括URL!

XSS 常见的注入方法：

- 在 HTML 中内嵌的文本中，恶意内容以 script 标签形成注入。
- 在内联的 JavaScript 中，拼接的数据突破了原本的限制（字符串，变量，方法名等）。
- 在标签属性中，恶意内容包含引号，从而突破属性值的限制，注入其他属性或者标签。
- 在标签的 href、src 等属性中，包含 `javascript:` (伪协议)等可执行代码。
- 在 onload、onerror、onclick 等事件中，注入不受控制代码。
- 在 style 属性和标签中，包含类似 `background-image:url("javascript:...");` 的代码（新版本浏览器已经可以防范）。
- 在 style 属性和标签中，包含类似 `expression(...)` 的 CSS 表达式代码（新版本浏览器已经可以防范）。

### XSS 攻击的分类

根据攻击的来源，XSS 攻击可分为存储型、反射型和 DOM 型三种。

#### 存储型 XSS

存储型 XSS 的攻击步骤：

1. 攻击者将恶意代码提交到目标网站的数据库中。
2. 用户打开目标网站时，网站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

存储型 XSS(又被称为持久性XSS)攻击常见于带有用户保存数据的网站功能，如论坛发帖、商品评论、用户私信等。

它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为**它不需要用户手动触发**。**任何允许用户存储数据的web程序都可能存在存储型XSS漏洞**，当攻击者提交一段XSS代码后，被服务器端接收并存储，当**所有浏览者访问某个页面时都会被XSS**。

#### 反射型 XSS

反射型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL 时，网站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。
3. 用户浏览器接收到响应后解析执行，混在其中的恶意代码也被执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库里，反射型 XSS 的恶意代码存在 URL 里。

反射型 XSS (也被称为非持久性XSS)漏洞常见于通过 URL 传递参数的功能，如网站搜索、跳转等。

由于需要用户主动打开恶意的 URL 才能生效，攻击者往往会结合多种手段诱导用户点击。

POST 的内容也可以触发反射型 XSS，只不过其触发条件比较苛刻（需要构造表单提交页面，并引导用户点击），所以非常少见。

#### DOM 型 XSS

DOM 型 XSS 的攻击步骤：

1. 攻击者构造出特殊的 URL，其中包含恶意代码。
2. 用户打开带有恶意代码的 URL。
3. 用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。
4. 恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网站接口执行攻击者指定的操作。

DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。

**注意:**
 DOM通常代表在html、xhtml和xml中的对象，使用DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器解析响应的直接参与，触发XSS**靠的是浏览器端的DOM解析**，所以防范**DOM型XSS完全就是前端的责任,必须注意!!!**。

**对比:**

| 类型       | 存储区                  | 插入点          |
| ---------- | ----------------------- | --------------- |
| 存储型 XSS | 后端数据库              | HTML            |
| 反射型 XSS | URL                     | HTML            |
| DOM 型 XSS | 后端数据库/前端存储/URL | 前端 JavaScript |

### 防御XSS

只要有输入数据的地方，就可能存在 XSS 危险。

#### 常用防范方法

- **httpOnly:** 在 cookie 中设置 HttpOnly 属性后，js脚本将无法读取到 cookie 信息。

- **输入过滤:** 一般是用于对于输入格式的检查，例如：邮箱，电话号码，用户名，密码……等，按照规定的格式输入。不仅仅是前端负责，后端也要做相同的过滤检查。因为攻击者完全可以绕过正常的输入流程，直接利用相关接口向服务器发送设置。

- **转义 HTML:** 如果拼接 HTML 是必要的，就需要对于引号，尖括号，斜杠进行转义,但这还不是很完善.想对 HTML 模板各处插入点进行充分的转义,就需要采用合适的转义库.(可以看下这个[库](https://link.juejin.im?target=https%3A%2F%2Fjsxss.com%2Fzh%2Findex.html),还是中文的)

  ```
  function escape(str) {
    str = str.replace(/&/g, '&amp;')
    str = str.replace(/</g, '&lt;')
    str = str.replace(/>/g, '&gt;')
    str = str.replace(/"/g, '&quto;')
    str = str.replace(/'/g, '&#39;')
    str = str.replace(/`/g, '&#96;')
    str = str.replace(/\//g, '&#x2F;')
    return str
  }
  复制代码
  ```

- **白名单:** 对于显示富文本来说，不能通过上面的办法来转义所有字符，因为这样会把需要的格式也过滤掉。这种情况通常采用白名单过滤的办法，当然也可以通过黑名单过滤，但是考虑到需要过滤的标签和标签属性实在太多，更加推荐使用白名单的方式。

#### 预防存储型和反射型 XSS 攻击

存储型和反射型 XSS 都是在服务端取出恶意代码后，插入到响应 HTML 里的，攻击者刻意编写的“数据”被内嵌到“代码”中，被浏览器所执行。

预防这两种漏洞，有两种常见做法：

- 改成纯前端渲染，把代码和数据分隔开。
- 对 HTML 做充分转义。

HTML转义前面已经说过,这里仅仅谈谈纯前端渲染

**纯前端渲染的过程：**

1. 浏览器先加载一个静态 HTML，此 HTML 中不包含任何跟业务相关的数据。
2. 然后浏览器执行 HTML 中的 JavaScript。
3. JavaScript 通过 Ajax 加载业务数据，调用 DOM API 更新到页面上。

在纯前端渲染中，我们会明确的告诉浏览器：下面要设置的内容是文本（`.innerText`），还是属性（`.setAttribute`），还是样式（`.style`）等等。浏览器不会被轻易的被欺骗，执行预期外的代码了。

但纯前端渲染还需注意避免 DOM 型 XSS 漏洞（例如 `onload` 事件和 `href` 中的 `javascript:xxx` 等，请参考下文”预防 DOM 型 XSS 攻击“部分）。

在很多内部、管理系统中，采用纯前端渲染是非常合适的。但对于性能要求高，或有 SEO 需求的页面，我们仍然要面对拼接 HTML 的问题,这时就需要对HTML进行充分的转义。

#### 预防 DOM 型 XSS 攻击

DOM 型 XSS 攻击，实际上就是网站前端 JavaScript代码本身不够严谨，把不可信的数据当作代码执行了。

在使用 `.innerHTML`、`.outerHTML`、`document.write()` 时要特别小心，不要把不可信的数据作为 HTML 插到页面上，而应尽量使用 `.textContent`、`.setAttribute()` 等。

如果用 Vue/React 技术栈，并且不使用 `v-html`/`dangerouslySetInnerHTML` 功能，就在前端 render 阶段避免 `innerHTML`、`outerHTML` 的 XSS 隐患。

DOM 中的内联事件监听器，如 `location`、`onclick`、`onerror`、`onload`、`onmouseover` 等，`<a>` 标签的 `href` 属性，JavaScript 的 `eval()`、`setTimeout()`、`setInterval()` 等，都能把字符串作为代码运行。如果不可信的数据拼接到字符串中传递给这些 API，很容易产生安全隐患，请务必避免。

```
<!-- 内联事件监听器中包含恶意代码 -->
<img onclick="UNTRUSTED" onerror="UNTRUSTED" src="data:image/png,">

<!-- 链接内包含恶意代码 -->
<a href="UNTRUSTED">1</a>

<script>
// setTimeout()/setInterval() 中调用恶意代码
setTimeout("UNTRUSTED")
setInterval("UNTRUSTED")

// location 调用恶意代码
location.href = 'UNTRUSTED'

// eval() 中调用恶意代码
eval("UNTRUSTED")
</script>
复制代码
```

###CSRF 跨站点请求伪造

### 什么是 CSRF

跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的 Web 应用程序上执行非本意的操作的攻击方法。如:攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。

####CSRF攻击流程

下图引自这位大佬的[浅谈CSRF攻击方式](https://link.juejin.im?target=https%3A%2F%2Fwww.cnblogs.com%2Fhyddd%2Farchive%2F2009%2F04%2F09%2F1432744.html),感谢!



![简而言之：网站过分相信用户](https://user-gold-cdn.xitu.io/2019/2/21/1690e0ca6c93e74a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



从上图可以看出，要完成一次CSRF攻击，受害者必须依次完成两个步骤：

- 1.登录受信任网站A，并在本地生成Cookie。
- 2.在不登出A的情况下，访问危险网站B。

看到这里，你也许会说：“如果我不满足以上两个条件中的一个，我就不会受到CSRF的攻击”。是的，确实如此，但你不能保证以下情况不会发生：

- 1.你不能保证你登录了一个网站后，不再打开一个tab页面并访问另外的网站。
- 2.**你不能保证你关闭浏览器了后，你本地的Cookie立刻过期**，你上次的会话已经结束。（事实上，关闭浏览器不能结束一个会话，但大多数人都会错误的认为关闭浏览器就等于退出登录/结束会话了......）
- 3.上图中所谓的攻击网站，可能是一个存在其他漏洞的可信任的经常被人访问的网站。

####常见的CSRF攻击类型

- #### GET类型的CSRF

GET类型的CSRF利用非常简单，只需要一个HTTP请求，一般会这样利用：

```
 <img src="http://bank.example/withdraw?amount=10000&for=hacker" > 
复制代码
```

在受害者访问含有这个img的页面后，浏览器会自动向`http://bank.example/withdraw?account=xiaoming&amount=10000&for=hacker`发出一次HTTP请求。bank.example就会收到包含受害者登录信息的一次跨域请求。

- #### POST类型的CSRF

这种类型的CSRF利用起来通常使用的是一个自动提交的表单，如：

```
 <form action="http://bank.example/withdraw" method=POST>
    <input type="hidden" name="account" value="xiaoming" />
    <input type="hidden" name="amount" value="10000" />
    <input type="hidden" name="for" value="hacker" />
</form>
<script> document.forms[0].submit(); </script> 
复制代码
```

访问该页面后，表单会自动提交，相当于模拟用户完成了一次POST操作。

POST类型的攻击通常比GET要求更加严格一点，但仍并不复杂。任何个人网站、博客，被黑客上传页面的网站都有可能是发起攻击的来源，**后端接口不能将安全寄托在仅允许POST上面**。

- #### 链接类型的CSRF

链接类型的CSRF并不常见，比起其他两种用户打开页面就中招的情况，这种需要用户点击链接才会触发。这种类型通常是在论坛中发布的图片中嵌入恶意链接，或者以广告的形式诱导用户中招，攻击者通常会以比较夸张的词语诱骗用户点击，例如：

```
  <a href="http://test.com/csrf/withdraw.php?amount=1000&for=hacker" taget="_blank">
  重磅消息！！
  <a/>
复制代码
```

####CSRF的特点

- 攻击一般发起在第三方网站，而不是被攻击的网站。被攻击的网站无法防止攻击发生。
- 攻击**利用受害者在被攻击网站的登录凭证，冒充受害者提交操作**；而不是直接窃取数据。
- 整个过程攻击者并不能获取到受害者的登录凭证，仅仅是“冒用”。
- 跨站请求可以用各种方式：图片URL、超链接、CORS、Form提交等等。部分请求方式可以直接嵌入在第三方论坛、文章中，难以进行追踪。

CSRF通常是跨域的，因为外域通常更容易被攻击者掌控。但是如果本域下有容易被利用的功能，比如**可以发图和链接的论坛和评论区，攻击可以直接在本域下进行，而且这种攻击更加危险。**

####CSRF与 XSS 区别

- **通常来说 CSRF 是由 XSS 实现的，CSRF 时常也被称为 XSRF（CSRF 实现的方式还可以是直接通过命令行发起请求等）。**
- 本质上讲，XSS 是代码注入问题，**CSRF 是 HTTP 问题。** XSS 是内容没有过滤导致浏览器将攻击者的输入当代码执行。**CSRF 则是因为浏览器在发送 HTTP 请求时候自动带上 cookie，而一般网站的 session 都存在 cookie里面(Token验证可以避免)。**

### 防御

- 验证码；强制用户必须与应用进行交互，才能完成最终请求。此种方式能很好的遏制 csrf，但是用户体验比较差。
- Referer check；请求来源限制，此种方法成本最低，但是并不能保证 100% 有效，因为服务器并不是什么时候都能取到 Referer，而且低版本的浏览器存在伪造 Referer 的风险。
- token；**token 验证的 CSRF 防御机制是公认最合适的方案。**(具体可以查看本系列前端鉴权中对token有详细描述)**若网站同时存在 XSS 漏洞的时候，这个方法也是空谈。**

##六、从输入URL到看到页面发生的全过程

总体来说分为以下几个过程:

1.浏览器的地址栏输入URL并按下回车。

2.浏览器查找当前URL是否存在缓存，并比较缓存是否过期。

3.DNS解析URL对应的IP。

4.根据IP建立TCP连接（三次握手）。

5.HTTP发起请求。

6.服务器处理请求，浏览器接收HTTP响应。

7.浏览器解析渲染页面。

8.关闭TCP连接（四次挥手）。

### 1. 输入URL并按下回车。

url一般包含这几个部分.可以顺带提以下知识点

**知识点:**

- 协议：主要是HTTP协议，HTTPS协议，FTP协议，FILe协议
- 域名： 定义因特网**域名**，比如 [google.com](https://link.juejin.im?target=http%3A%2F%2Fgoogle.com)
- 端口号：通常默认都是隐藏的 **http默认端口号为80 https默认端口号为443**
- 补充:  同源策略 - 在前端进行数据请求时，由于浏览器的同源策略，协议，域名，端口号有一个不同会存在跨域请求，需要进行跨域处理

### 2.浏览器查找当前URL是否存在缓存，并比较缓存是否过期。

浏览器首先查询当前URL是否有缓存,有的话,再查询是否过期,没过期则读缓存.过期了则访问web服务器.

**知识点:** 	 详细解释可以看本系列的"浏览器缓存"这节.

### 3.DNS解析URL对应的IP。

#### **解析过程:**

1.首先浏览器会查看自己的DNS缓存是否存在.

2.如果没有找到,浏览器会**先查找本地hosts文件是否有这个网址映射关系**，如果有就调用这个IP地址映射，完成域名解析。

3.如果没有找到,则会在操作系统缓存中查找本地的DNS解析器缓存，如果找到则返回。

4.如果没有找到,则会在路由器缓存中进行查找,如果找到则返回。

5.如果还是没有找到,则会按ISP(运营商)DNS缓存、根域名服务器、顶级域名服务器、主域名服务器的顺序，逐步读取缓存，直到拿到IP地址.

#### 为什么要DNS解析

互联网上每一台计算机的唯一标识是它的IP地址，但是IP地址并不方便记忆。用户更喜欢用方便记忆的网址去寻找互联网上的其它计算机，也就是上面提到的百度的网址。所以互联网设计者需要在用户的方便性与可用性方面做一个权衡，这个权衡就是一个网址到IP地址的转换，这个过程就是DNS解析，即实现了网址到IP地址的转换

#### IP 地址

IP 地址是指互联网协议地址，是 IP Address 的缩写。IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。IP 地址是一个 32 位的二进制数，比如 127.0.0.1 为本机 IP。

**域名就相当于 IP 地址乔装打扮的伪装者，带着一副面具。它的作用就是便于记忆和沟通的一组服务器的地址**。用户通常使用主机名或域名来访问对方的计算机，而不是直接通过 IP 地址访问。**因为与 IP 地址的一组纯数字相比，用字母配合数字的表示形式来指定计算机名更符合人类的记忆习惯。但要让计算机去理解名称，相对而言就变得困难了。因为计算机更擅长处理一长串数字。为了解决上述的问题，DNS 服务应运而生。**

#### 什么是域名解析

DNS 协议提供通过域名查找 IP 地址，或逆向从 IP 地址反查域名的服务。**DNS 是一个网络服务器，我们的域名解析简单来说就是在 DNS 上记录一条信息记录**。

```
例如 baidu.com  220.114.23.56（服务器外网IP地址）80（服务器端口号）
复制代码
```

#### **相关名词解释:**

- 浏览器缓存：浏览器会按照一定的频率缓存 DNS 记录。
- hosts文件:   Hosts是一个没有扩展名的系统文件，可以用记事本等工具打开，其作用就是将一些常用的网址域名与其对应的IP地址建立一个关联“数据库”.一般位于系统盘C:\Windows\System32\drivers\etc中，如果进去没有看到Hos文件，是因为某些系统将Host文件隐藏了。
- 操作系统缓存：如果浏览器缓存中找不到需要的 DNS 记录，那就去操作系统的DNS缓存中读取该域名所对应的IP地址。
- 路由缓存：路由器也有 DNS 缓存。
- ISP 的 DNS 服务器：ISP 是互联网服务提供商(Internet Service Provider)的简称，ISP 有专门的 DNS 服务器应对 DNS 查询请求。
- 根服务器：ISP 的 DNS 服务器还找不到的话，它就会向根服务器发出请求，进行递归查询（DNS 服务器先问根域名服务器`.com` 域名服务器的 IP 地址，然后再问.baidu 域名服务器，依次类推）

### 4.根据IP建立TCP连接（三次握手）

#### **三次握手的过程:**

- **客户端发送一个syn包:即带有 SYN=1，Seq=x 的数据包到服务器端口，并进入SYN_SENT状态，等待服务器确认；**（第一次握手，由浏览器发起，告诉服务器我要发送请求了）
- **服务器收到syn包，必须确认客户的SYN，同时发回一个带 SYN=1， ACK=x+1， Seq=y 的响应包以示传达确认信息,即SYN+ACK包，此时服务器进入SYN_RECV状态；**（第二次握手，由服务器发起，告诉浏览器我准备接受了，你赶紧发送吧）
- **客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK,即回传一个带 ACK=y+1， Seq=Z 的数据包，代表“握手结束”**（第三次握手，由浏览器发送，告诉服务器，我马上就发了，准备接受吧）



![img](https://user-gold-cdn.xitu.io/2019/2/22/16914083b8093f55?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



完成TCP连接后开使向服务器进行请求

#### **为啥需要三次握手**

谢希仁著《计算机网络》中讲“三次握手”的目的是“**为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误**”。

### 5.HTTP发起请求 && 6.服务器处理请求，浏览器接收HTTP响应。

- 完整的HTTP请求包含请求起始行、请求头部、请求主体三部分。



![img](https://user-gold-cdn.xitu.io/2019/2/22/1691406a752c9a9b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- 服务器在收到浏览器发送的HTTP请求之后，会将收到的HTTP报文封装成HTTP的Request对象，并通过不同的Web服务器进行处理，处理完的结果以HTTP的Response对象返回，主要包括状态码，响应头，响应报文三个部分。
- 综合起来,完整的HTTP请报文一般包括了：**通用头部**，**请求/响应头部**，**请求/响应体**

#### **通用头部**

包括如下：

```
//General 

Request Url: 请求的web服务器地址

Request Method: 请求方式
（Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）

Status Code: 请求的返回状态码，如200代表成功

Remote Address: 请求的远程服务器地址（会转为IP）

Referrer Policy: (引用策略)用来监管哪些访问来源信息 (IE暂不支持)
复制代码
```

#### **请求/响应头部:**

常用的请求头部（部分）：

```
Accept: 接收类型，表示浏览器支持的MIME类型
（对标服务端返回的Content-Type）
Accept-Encoding：浏览器支持的压缩类型,如gzip等,超出类型不能接收
Content-Type：客户端发送出去实体内容的类型
Cache-Control: 指定请求和响应遵循的缓存机制，如no-cache
If-Modified-Since：对应服务端的Last-Modified，用来匹配看文件是否变动，只能精确到1s之内，http1.0中
Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1中
If-None-Match：对应服务端的ETag，用来匹配文件内容是否改变（非常精确），http1.1中
Cookie: 有cookie并且同域访问时会自动带上
Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如keep-alive
Host：请求的服务器URL
Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin比Referer更尊重隐私
Referer：该页面的来源URL(适用于所有类型的请求，会精确到详细页面地址，csrf拦截常用到这个字段)
User-Agent：用户客户端的一些必要信息，如UA头部等

复制代码
```

常用的响应头部（部分）：

```
Access-Control-Allow-Headers: 服务器端允许的请求Headers
Access-Control-Allow-Methods: 服务器端允许的请求方法
Access-Control-Allow-Origin: 服务器端允许的请求Origin头部（譬如为*）
Content-Type：服务端返回的实体内容的类型
Date：数据从服务器发送的时间
Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
Last-Modified：请求资源的最后修改时间
Expires：应该在什么时候认为文档已经过期,从而不再缓存它
Max-age：客户端的本地资源应该缓存多少秒，开启了Cache-Control后有效
ETag：请求变量的实体标签的当前值
Set-Cookie：设置和页面关联的cookie，服务器通过这个头部把cookie传给客户端
Keep-Alive：如果客户端有keep-alive，服务端也会有响应（如timeout=38）
Server：服务器的一些相关信息
复制代码
```

一般来说，请求头部和响应头部是匹配分析的。

譬如，请求头部的Accept要和响应头部的Content-Type匹配，否则会报错

譬如，跨域请求时，请求头部的Origin要匹配响应头部的Access-Control-Allow-Origin，否则会报跨域错误

譬如，在使用缓存时，请求头部的If-Modified-Since、If-None-Match分别和响应头部的Last-Modified、ETag对应

#### **请求/响应实体:**

http请求时，除了头部，还有消息实体，一般来说

请求实体中会将一些需要的参数都放入进入（用于post请求）。

譬如实体中可以放参数的序列化形式（`a=1&b=2`这种），或者直接放表单对象（`Form Data`对象，上传时可以夹杂参数以及文件），等等

而一般响应实体中，就是放服务端需要传给客户端的内容

一般现在的接口请求时，实体中就是对于的信息的json格式，而像页面请求这种，里面就是直接放了一个html字符串，然后浏览器自己解析并渲染。



![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="596" height="800"></svg>)



### 6.浏览器解析渲染页面

#### **流程简述**

浏览器内核拿到内容后，渲染步骤大致可以分为以下几步：

```
1. 解析HTML，构建DOM树

2. 解析CSS，生成CSS规则树

3. 合并DOM树和CSS规则，生成render树

4. 布局render树（Layout/reflow），负责各元素尺寸、位置的计算

5. 绘制render树（paint），绘制页面像素信息

6. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上

PS:
reflow：也称作layout，中文叫回流，一般意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树，这个过程称为reflow。

repaint：中文重绘，意味着元素发生的改变只是影响了元素的一些外观之类的时候(例如：背景色，边框颜色，文字颜色等)，此时只需要应用新样式绘制这个元素就可以了。

复制代码
```

#### 1.根据 HTML 解析 DOM 树

- 根据 HTML 的内容，将标签按照结构解析成为 DOM 树，DOM 树解析的过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。
- 在读取 HTML 文档，构建 DOM 树的过程中，若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。

#### 2.根据 CSS 解析生成 CSS 规则树

- 解析 CSS 规则树时 js 执行将暂停，直至 CSS 规则树就绪。
- 浏览器在 CSS 规则树生成之前不会进行渲染。

#### 3.结合 DOM 树和 CSS 规则树，生成渲染树

- DOM 树和 CSS 规则树全部准备好了以后，浏览器才会开始构建渲染树。
- 精简 CSS 并可以加快 CSS 规则树的构建，从而加快页面相应速度。

#### 4.根据渲染树计算每一个节点的信息（布局）

- 布局：通过渲染树中渲染对象的信息，计算出每一个渲染对象的位置和尺寸
- 回流：在布局完成后，发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。

#### 5.根据计算好的信息绘制页面

- 绘制阶段，系统会遍历呈现树，并调用呈现器的“paint”方法，将呈现器的内容显示在屏幕上。
- 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。
- 回流：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。



![img](https://user-gold-cdn.xitu.io/2019/2/22/1691409e234135e7?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### 7.关闭TCP连接（四次挥手）

通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。



![img](https://user-gold-cdn.xitu.io/2019/2/22/169140a85c0fec37?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



> 1. 第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。(第一次挥手：由浏览器发起的，发送给服务器，我请求报文发送完了，你准备关闭吧)
> 2. 第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。(第二次挥手：由服务器发起的，告诉浏览器，我请求报文接受完了，我准备关闭了，你也准备吧)
> 3. 第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。(第三次挥手：由服务器发起，告诉浏览器，我响应报文发送完了，你准备关闭吧)
> 4. 第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。(第四次挥手：由浏览器发起，告诉服务器，我响应报文接受完了，我准备关闭了，你也准备吧)



## 七、事件流的概念

先从概念说起，DOM 事件流分为三个阶段：`捕获阶段`、`目标阶段`、`冒泡阶段`。先调用捕获阶段的处理函数，其次调用目标阶段的处理函数，最后调用冒泡阶段的处理函数。



![img](https://user-gold-cdn.xitu.io/2019/2/24/1691f3e556cd038b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



网景公司提出了 `事件捕获` 的事件流。这就好比采矿的小游戏，每次都会从地面开始一路往下，抛出抓斗，捕获矿石。在上图中就是，某个 div 元素触发了某个事件，最先得到通知的是 window，然后是 document，依次往下，直到真正触发事件的那个目标元素 div 为止。

而 `事件冒泡` 则是由微软提出的，与之顺序相反。还是刚才的采矿小游戏，命中目标后，抓斗再沿路收回，直到冒出地面。在上图中就是，事件会从目标元素 div 开始依次往上，直到 window 对象为止。

w3c 为了制定统一的标准，采取了折中的方式：`先捕获在冒泡`。同一个 DOM 元素可以注册多个同类型的事件，通过 addEventListener 和 removeEventListener 进行管理。addEventListener 的第三个参数，就是为了捕获和冒泡准备的。

`注册事件`(addEventListener) 有三个参数，分别为："事件名称", "事件回调", "捕获/冒泡"(布尔型，true代表捕获事件，false代表冒泡事件)。

```javascript
target.addEventListener(type, listener[, useCapture]);
```

- type 表示事件类型的字符串。
- listener 是一个实现了 EventListener 接口的对象，或者是一个函数。当所监听的事件类型触发时，会接收到一个事件通知对象（实现了 Event 接口的对象）。
- capture 表示 listener 会在该类型的事件捕获阶段，传播到该 EventTarget 时触发，它是一个 Boolean 值。

`解除事件`(removeEventListener) 也有三个参数，分别为："事件名称", "事件回调", "捕获/冒泡"(Boolean 值，这个必须和注册事件时的类型一致)。

```javascript
target.removeEventListener(type, listener[, useCapture]);
```

要想注册过的事件能够被解除，必须将回调函数保存起来，否则无法解除。例如这样：

```javascript
const btn = document.getElementById("test");

//将回调存储在变量中
const fn = function(e){
    alert("ok");
};

//绑定
btn.addEventListener("click", fn, false);

//解除
btn.removeEventListener("click", fn, false);
```

###事件捕获和冒泡的5个注意点

当有多层交互嵌套时，事件捕获和冒泡的先后顺序，似乎不是那么好理解。接下来，将分 5 种情况讨论它们的顺序，以及如何规避意外情况的发生。

#### 1.在外层 div 注册事件，点击内层 div 来触发事件时，捕获事件总是要比冒泡事件先触发(与代码顺序无关)

假设，有这样的 html 结构：

```javascript
<div id="test" class="test">
   <div id="testInner" class="test-inner"></div>
</div>
```

然后，我们在外层 div 上注册两个 click 事件，分别是捕获事件和冒泡事件，代码如下：

```javascript
const btn = document.getElementById("test");
 
//捕获事件
btn.addEventListener("click", function(e){
    alert("capture is ok");
}, true);
 
//冒泡事件
btn.addEventListener("click", function(e){
    alert("bubble is ok");
}, false);
```

点击内层的 div，先弹出 capture is ok，后弹出 bubble is ok。只有当真正触发事件的 DOM 元素是内层的时候，外层 DOM 元素才有机会模拟捕获事件和冒泡事件。

#### 2.当在触发事件的 DOM 元素上注册事件时，哪个先注册，就先执行哪个

html 结构同上，js 代码如下：

```javascript
const btnInner = document.getElementById("testInner");

//冒泡事件
btnInner.addEventListener("click", function(e){
    alert("bubble is ok");
}, false);
 
//捕获事件
btnInner.addEventListener("click", function(e){
    alert("capture is ok");
}, true);
```

本例中，冒泡事件先注册，所以先执行。所以，点击内层 div，先弹出 `bubble is ok`，再弹出 `capture is ok`。

#### 3.当外层 div 和内层 div 同时注册了捕获事件时，点击内层 div 时，外层 div 的事件一定会先触发

js 代码如下：

```javascript
const btn = document.getElementById("test");
const btnInner = document.getElementById("testInner");

btnInner.addEventListener("click", function(e){
    alert("inner capture is ok");
}, true);

btn.addEventListener("click", function(e){
    alert("outer capture is ok");
}, true);
```

虽然外层 div 的事件注册在后面，但会先触发。所以，结果是先弹出 `outer capture is ok`，再弹出 `inner capture is ok`。

#### 4.同理，当外层 div 和内层 div 都同时注册了冒泡事件，点击内层 div 时，一定是内层 div 事件先触发。

```javascript
const btn = document.getElementById("test");
const btnInner = document.getElementById("testInner");

btn.addEventListener("click", function(e){
    alert("outer bubble is ok");
}, false);

btnInner.addEventListener("click", function(e){
    alert("inner bubble is ok");
}, false);
```

先弹出 `inner bubble is ok`，再弹出 `outer bubble is ok`。

#### 5.阻止事件的派发

通常情况下，我们都希望点击某个 div 时，就只触发自己的事件回调。比如，明明点击的是内层 div，但是外层 div 的事件也触发了，这是就不是我们想要的了。这时，就需要阻止事件的派发。

事件触发时，会默认传入一个 event 对象，这个 event 对象上有一个方法：`stopPropagation`。MDN 上的解释是：**阻止 捕获 和 冒泡 阶段中，当前事件的进一步传播**。所以，通过此方法，让外层 div 接收不到事件，自然也就不会触发了。

```javascript
btnInner.addEventListener("click", function(e){
    //阻止冒泡
    e.stopPropagation();
    alert("inner bubble is ok");
}, false);
```

###事件代理

我们经常会遇到，要监听列表中多项 li 的情况，假设我们有一个列表如下：

```javascript
<ul id="list">
    <li id="item1">item1</li>
    <li id="item2">item2</li>
    <li id="item3">item3</li>
    <li id="item4">item4</li>
</ul>
```

如果我们要实现以下功能：当鼠标点击某一 li 时，输出该 li 的内容，我们通常的写法是这样的：

```javascript
window.onload=function(){
    const ulNode = document.getElementById("list");
    const liNodes = ulNode.children;
    for(var i=0; i<liNodes.length; i++){
        liNodes[i].addEventListener('click',function(e){
            console.log(e.target.innerHTML);
        }, false);
    }
}
```

在传统的事件处理中，我们可能会按照需要，为每一个元素添加或者删除事件处理器。然而，事件处理器将有可能导致内存泄露，或者性能下降，用得越多这种风险就越大。JavaScript 的事件代理，则是一种简单的技巧。

#### 用法及原理

事件代理，用到了在 JavaSciprt 事件中的两个特性：事件冒泡 和 目标元素。使用事件代理，我们可以把事件处理器添加到一个元素上，等待一个事件从它的子级元素里冒泡上来，并且可以得知这个事件是从哪个元素开始的。

改进后的 js 代码如下：

```javascript
window.onload=function(){
    const ulNode=document.getElementById("list");
    ulNode.addEventListener('click', function(e) {
        /*判断目标事件是否为li*/
        if(e.target && e.target.nodeName.toUpperCase()=="LI"){
            console.log(e.target.innerHTML);
        }
    }, false);
};
```

###一些常用技巧

回到文章开头的问题：了解事件流的顺序，对日常的工作有什么帮助呢？我总结了以下几个注意点。

#### 1. 阻止默认事件

比如 href 的链接跳转，submit 的表单提交等。可以在方法的最后，加上一行 `return false;`。它会阻止通过 on 的方式绑定的事件的默认事件。

```javascript
ele.onclick = function() {
    ……
    // 通过返回 false 值，阻止默认事件行为
    return false;
}
```

另外，重写 onclick 会覆盖之前的属性，所以解绑事件可以这么写：

```javascript
// 解绑事件，将 onlick 属性设为 null 即可
ele.onclick = null;
```

#### 2. stopPropagation 和 stopImmediatePropagation

前面说过 stopPropagation 的定义是：终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。事件不再被分派到其他节点上。

```javascript
// 事件捕获到 ele 元素后，就不再向下传播了
ele.addEventListener('click', function (event) {
  event.stopPropagation();
}, true);

// 事件冒泡到 ele 元素后，就不再向上传播了
ele.addEventListener('click', function (event) {
  event.stopPropagation();
}, false);
```

但是，stopPropagation 只会阻止当前元素 `同类型的` 事件冒泡或捕获的传播，并不会阻止该元素上 `其他类型` 事件的监听。以 click 事件为例：

```javascript
ele.addEventListener('click', function (event) {
  event.stopPropagation();
  console.log(1);
});

ele.addEventListener('click', function(event) {
  // 仍然可以触发
  console.log(2);
});
```

如果想禁用之后所有的 click 事件，就要用到 stopImmediatePropagation 了。但是，需要注意的是，stopImmediatePropagation 只会禁用之后注册的同类型的监听事件。就比如阻止了之后的 click 事件监听函数，但别的事件类型如 mousedown、dblclick 之类，还是可以监听到的。

```javascript
ele.addEventListener('click', function (event) {
    event.stopImmediatePropagation();
    console.log(1);
});

ele.addEventListener('click', function(event) {
    // 不会触发
    console.log(2);
});

ele.addEventListener('mousedown', function(event) {
    // 会触发
    console.log(3);
});
```

#### 3. jquery 中的 return false;

jquery 中的 on 是事件冒泡。当用 return false; 阻止浏览器的默认行为时，会做下面这 3 件事：

- event.preventDefault();
- event.stopPropagation();
- 停止回调函数执行并立即返回。

这 3 件事中，只有 preventDefault 是用来阻止默认行为的。除非你还想阻止事件冒泡，否则直接用 return false; 会埋下隐患。

#### 4. angular 中的 $event

angular 是个包罗万象的框架，似乎学完它的一整套之后，就能玩转世界了。它加工封装了许多原生的东西，其中就包括了 event，只是前面需要加一个 $，表示这是 angular 中的特有对象。

```javascript
// template
<div>
    <button (click)="doSomething($event)">Click me</button>
</div>

// js
doSomething($event: Event) {
    $event.stopPropagation();
    ...
}
```

![event 在这里作为一个变量，`显式地` 传入回调函数，之后就可以将](https://juejin.im/equation?tex=event%20%E5%9C%A8%E8%BF%99%E9%87%8C%E4%BD%9C%E4%B8%BA%E4%B8%80%E4%B8%AA%E5%8F%98%E9%87%8F%EF%BC%8C%60%E6%98%BE%E5%BC%8F%E5%9C%B0%60%20%E4%BC%A0%E5%85%A5%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%EF%BC%8C%E4%B9%8B%E5%90%8E%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%B0%86)event 当做原生的事件对象来用了。

#### 5. vue 中的 native 修饰符

在 vue 的自定义组件中绑定原生事件，需要用到修饰符 native。

那是因为，我们的自定义组件，最终会渲染成原生的 html 标签，而非类似于 这样的自定义组件。如果想让一个普通的 html 标签触发事件，那就需要对它做事件监听(addEventListener)。修饰符 native 的作用就在这里，它可以在背后帮我们绑定了原生事件，进行监听。

一个常用的场景是，配合 element-ui 做登录界面时，输完账号密码，想按一下回车就能登录。就可以像下面这样用修饰符：

```vue
<el-input
    class="input"
    v-model="password" type="password"
    @keyup.enter.native="handleSubmit">
</el-input>
```

el-input 就是自定义组件，而 keyup 就是原生事件，需要用 native 修饰符进行绑定才能监听到。

#### 6. react 中的合成事件

想要在 react 的事件回调中使用 event 对象，会产生困扰，会发现不少原生的属性都是 null。

那是因为在 react 中的事件，其实是合成事件（SyntheticEvent），并不是浏览器的原生事件，但它也符合 w3c 规范。

举一个简单的例子，我们要实现一个组件，它有一个按钮，点击按钮后会显示一张图片，点击这张图片之外的任意区域，可以隐藏这张图片，但是点击该图片本身时，不会隐藏。代码如下：

```javascript
class ShowImg extends Component {
    constructor(props) {
        super(props);
        this.state = {
          active: false
        };
    }
  
    componentDidMount() {
        document.addEventListener('click', this.hideImg.bind(this));
    }

    componentWillUnmount() {
        document.removeEventListener('click', this.hideImg);
    }
    
    hideImg () {
        this.setState({ active: false });
    }
    
    handleClickBtn() {
        this.setState({ active: !this.state.active });
    }
  
    handleClickImg (e) {
        e.stopPropagation();
    }

    render() {
        return (
            <div className="img-wrapper">
                <button
                    className="showImgBtn"
                    onClick={this.handleClickBtn.bind(this)}>
                    显示图片
                </button>
                <div
                    className="img"
                    style={{ display: this.state.active ? 'block' : 'none' }}
                    onClick={this.handleClickImg.bind(this)}>
                    <img src="@/assets/avatar.jpg" >
                </div>
            </div>
        );
    }
}
```

按照之前说的原生事件机制，我们会错误地认为通过：

```javascript
handleClickImg (e) {
    e.stopPropagation();
}
```

就可以阻止事件的派发了，但其实没法这么做。想要解决这个问题，当然也不复杂，就把 react 的事件和原生事件分开即可。

```javascript
componentDidMount() {
    document.addEventListener('click', this.hideImg.bind(this));
    
    document.addEventListener('click', this.imgStopPropagation.bind(this));
}

componentWillUnmount() {
    document.removeEventListener('click', this.hideImg);
    
    document.removeEventListener('click', this.imgStopPropagation);
}

hideImg () {
    this.setState({ active: false });
}

imgStopPropagation (e) {
    e.stopPropagation();
}
```

#### 7. 事件对象 event

当对一个元素进行事件监听的时候，它的回调函数里就会默认传递一个参数 event，它是一个对象，包含了许多属性。我列出了一些比较常用的属性：

- event.target：指的是触发事件的那个节点，也就是事件最初发生的节点。
- event.target.matches：可以对关键节点进行匹配，来执行相应操作。
- event.currentTarget：指的是正在执行的监听函数的那个节点。
- event.isTrusted：表示事件是否是真实用户触发。
- event.preventDefault()：取消事件的默认行为。
- event.stopPropagation()：阻止事件的派发（包括了捕获和冒泡）。
- event.stopImmediatePropagation()：阻止同一个事件的其他监听函数被调用。