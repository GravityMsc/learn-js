### 为什么需要懒加载

通常用户打开网页时，整个网页的内容将被下载并且呈现在一个页面中，虽然允许浏览器缓存页面，但是不能保证用户查看所有下载的内容，例如一个照片墙应用，可能用户仅仅查看第一个图片之后离开，结果就是白白浪费了内存和带宽。因此我们需要当用户需要访问页面的一部分时才去加载内容，而不是一开始就去加载全部内容。

### 如何实现懒加载

当有人向网页请求图像，视频等资源，资源引用一个小的占位符，当用户浏览网页，实际的资源被浏览器缓存，并且当资源在屏幕上可见时替换占位符，例如，如果永辉加载网页并立即离开网页，则除了网页的顶部之外没有任何内容被加载。

![懒加载的示意](https://user-gold-cdn.xitu.io/2018/2/4/16160980c248ca64?imageslim)

### 懒加载的具体实现

以加载图片为例，我们需要将img标签中设置一个data-src属性，它指向的是实际上我们需要加载的图像，而img的src指向一张默认的图片，如果为空的话也会向服务器发送请求。

```html
<img src="default.img" data-src="www.example.com/1.jpg">
```

之后当用户访问的可视区域的img元素时，将src的值替换为data-src指向的实际资源加载的图像。

#### 具体代码

```javascript
const lazy = (el) => {
    let scrTop = getTop();
    let windowHeight = document.documentElement.clientHeight;
    function getTop(){
        return document.documentElement.scrollTop || document.body.scrollTop;
    }
    function getOffset(node){
        return node.getBoundingClientRect().top + scrTop;
    }
    function inView(node){
        // 设立阈值
        const threshold = 0;
        const viewTop = scrTop;
        const viewBot = viewTop + windowHeight;
        
        const nodeTop = getOffset(node);
        const nodeBot = nodeTop + node.offsetHeight;
        
        const offset = (threshold / 100) * windowHeight;
        console.log((nodeBot >= viewTop - offset), (nodeTop <= viewBot + offset));
        return (nodeBot >= viewTop - offset) && (nodeTop <= viewBot + offset);
    }
    function check(node){
        let el = document.querySelector(node);
        let images = [...el.querySelectorAll('img')];
        images.forEach(img => {
            if(inView(img)){
                img.src = img.dataset.src;
            }
        });
    }
    check(el);
}

window.onscroll = function(){
    lazy('.foo');
}
```

### 现代化懒加载实现方法

通过上面的例子的实现，我们要实现懒加载都需要去监听scroll事件，尽管我们可以通过函数节流的方式来阻止高频率的执行函数，但是我们还是需要去计算scrollTop，offsetHeight等属性，有没有简单的不需要计算这些属性的方式呢，答案是有的——IntersectionObserver。

根据MDN：

> IntersectionObserver API为开发者提供了一种可以一步监听目标元素与其祖先或视窗（viewport）处于交叉状态的方式。祖先元素与视窗（viewport）被称为根（root）。

简单来说就是观察一个元素和另一个元素是否重叠。

IntersectionObserver初始化的过程中提供了三个主要元素的配置：

