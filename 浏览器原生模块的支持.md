还记得当初入门前端开发的时候写过的Hello World么？一开始我们先创建了一个HTML文件，在\<body>标签里写上网页内容；后来需要学习页面交互逻辑时，在HTML markup里增加了一个\<script src="script.js">标签引入外部script.js代码，script.js负责页面交互逻辑。

随着前端社区JavaScript模块化的发展，我们现在的习惯是拆分JS代码模块后使用Webpack打包为一个bundle.js文件，再在HTML中使用\<script scr="bundle.js">标签引入打包后的JS。这意味着我们的前端开发工作流从“石器时代”跨越到了“工业时代”，但是对浏览器来说并没有质的改变，它所加载的代码依然是一个bundle.js，与我们在Hello World时加载脚本的方式没什么两样。

直到浏览器对ES Module标准的原生支持，改变了这种情况。目前大多数浏览器已经支持通过\<script type="module">的方式加载标准的ES模块，正是时候让我们重新学习script相关的知识点了。

### 复习：defer和async的区别

请听题：

**Q：有两个script元素，一个从CDN加载lodash，另一个从本地加载script.js，假设总是本地脚本下载更快，那么以下plain.html、async.html和defer.html分别输出什么？**

```javascript
// script.js
try {
    console.log(_.VERSION);
} catch (error) {
    console.log('Lodash Not Available');
}
console.log(document.body ? 'YES' : 'NO');
```

```html
// A. plain.html
<head>
    <script scr="htttps://cdn.jsdelivr.net/npm/lodash@4.17.10/lodash.min.js"></script>
    <script src="script.js"></script>
</head>

// B. async.html
<head>
    <script scr="htttps://cdn.jsdelivr.net/npm/lodash@4.17.10/lodash.min.js"></script>
    <script src="script.js" async></script>
</head>

// C. defer.html
<head>
    <script scr="htttps://cdn.jsdelivr.net/npm/lodash@4.17.10/lodash.min.js"></script>
    <script src="script.js" defer></script>
</head>
```

如果你知道答案，就可以跳过这一节，否则就要复习一下了。

首先 A. plain.html的输出是：

```bash
4.17.10
NO
```

也就是说script.js在执行时，lodash已下载并执行完毕，但document.body尚未加载。

在defer和async属性诞生之前，最初浏览器加载脚本是采用同步模型的。浏览器解析器在自上而下解析HTML标签，遇到script标签时会暂停对文档其他标签的解析而读取script标签。此时：

* 如果script标签无src属性，为内敛脚本，解析器会直接读取标签的textContent，由JS解释器执行JS代码
* 如果script有src属性，则从src指定的URI发起网络请求下载脚本，然后由JS解释器执行

无论哪种情况，都会阻塞浏览器的解析器，刚刚说到浏览器是自上而下解析HTML Markup的，所以这个阻塞的特性就决定了，script标签中的脚本执行时，位于该script标签以上的DOM元素是可用的，位于其以下的DOM元素不可用。

如果我们的脚本的执行需要操作前面的DOM元素，并且后面的DOM元素的加载和渲染依赖该脚本的执行结果，这样的阻塞是有意义的。但如果情况相反，那么脚本的执行只会拖慢页面的渲染。

正因如此，2006年的《Yahoo 网站优化建议》中有一个著名的规则：

> 把脚本放在body底部

但现代浏览器早已支持给\<script>标签加上defer或async属性，二者的共同点是都不会阻塞HTML解析器。

当文档只有一个script标签时，defer与async并没有显著差异。但当有多个script标签时，二者表现不同：

* async脚本每个都会在下载完成后立即执行，无关script标签出现的顺序
* defer脚本会根据script标签顺序先后执行

所以以上问题中，后两种情况分别输出：