### 0. 引言

作为互联网项目，最重要的便是用户体验，在举国“互联网+”的热潮中，用户至上也已经被大多数企业所接受，特别是在如今移动端快速发展的时代，我们的网页不仅只是呈现在用户的PC浏览器里，更多的时候，用户是通过移动产品浏览我们的网页。加之有越来愈多的开发者投入到Web APP和Hybrid APP的开发队伍中，性能，又再一次成为了被程序员们重点关注的话题。我曾经看到过这样一句话：一个网站的体验，决定了用户是否愿意去了解网站的功能；而网站的功能，决定了用户是否会一票否决网站的体验。这是改版自网络的一句流行语，但却把网站性能这件事说的十分透彻，特别是在网站这样的项目中，如果一个用户需要超过5s才能看见页面，它会毫不犹豫地关闭它。

性能优化，作为工程师界的“上乘武功”，是我们在开发中老生常谈的话题，也是一名开发者从入门向资深进阶的必经阶段，虽然我们看到过很多的标准、军规，但在真正实践中，却常常力不从心，不知道落下了什么，不知道性能是否还有进一步优化的空间。

对于网站的性能，在行业内有很多既定的指标，但就以我们Front-Enders而言，应该更加关注以下指标：白屏时间、首屏时间、整页时间、DNS时间、CPU占用率。

今天，我们将从性能优化的三大方面工作逐步展开介绍，其中包括网络传输性能、页面渲染性能以及JS阻塞性能，系统性第带着读者们体验性能优化的实践流程。



### 1. 网络传输性能优化

在开始介绍网络传输性能优化这项工作之前，我们需要了解浏览器处理用户请求的过程，那么久必须奉上这张图了。

![浏览器从网络传输数据到构建DOM的过程](https://user-gold-cdn.xitu.io/2018/5/28/163a4d01fdc524f3?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

这是navigation timing检测指标图，从图中我们可以看出，浏览器在得到用户请求之后，经历了下面这些阶段：重定向->拉取缓存->DNS查询->建立TCP连接->发起请求->接收响应->处理HTML元素->元素加载完成。不着急，我们将对其中的细节一步步展开讨论：

#### 1.1 浏览器缓存

我们都知道，浏览器在向服务器发起请求前，会先查询本地是否有相同的文件，如果有，就会直接拉取本地缓存，这和我们在后台部署的Redis、Memcache类似，都是起到了中间缓冲的作用，我们先看看浏览器处理缓存的策略：

![浏览器处理缓存的策略](https://user-gold-cdn.xitu.io/2018/5/28/163a4d01fdd197b6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

因为网上的图片太笼统了，而且我翻过很多讲缓存的文章，很少有将状态码还有什么时候将缓存存放在内存（Memory）中什么时候将缓存存放在硬盘中（disk）系统地整理出来，所以我自己绘制了一张浏览器缓存机制流程图，结合这张图再更深入地说明浏览器的缓存机制。

这里我们可以使用chrome devtools里的network面板查看网络传输的相关信息：

（这里需要特别注意，在我们进行缓存调试时，需要去除network面板顶部的Disable cache勾选项，否则浏览器将始终不会从缓存中拉取数据）

![chrome devtools查看缓存](https://user-gold-cdn.xitu.io/2018/5/28/163a4d01fde62f77?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

浏览器默认的缓存是放在内存中的，但我们知道，内存里的缓存会因为进程的结束或者说浏览器的关闭而被清除，而存在硬盘的缓存才能够被长期保留下去。很多时候，我们在network面板中各请求的size项里，会看到两种不同的状态：from memory cache 和 from disk cache，前者指缓存来自内存，后者指缓存来自硬盘。而控制缓存存放位置的，不是别人，就是我们在服务器上设置的Etag字段。在浏览器收到服务器响应后，会检测响应头部（Header），如果有ETag字段，那么浏览器就会将本次缓存写入硬盘中。

之所以拉取缓存会出现200、304两种不同的状态码，取决于浏览器是否有向浏览器发起验证请求。只有向服务器发起验证请求并确认缓存未被更新，才会返回304状态码。

这里我以nginx为例，谈谈如何配置缓存。

首先，我们进入nginx的配置文档

$ vim nginxPath/conf/nginx.conf

在配置文档内插入如下两项：

```bash
etag on;	// 开启etag验证
expires 7d;	// 设置缓存过期时间为7天
```

打开我们的网站，在chrome devtools的network面板中观察我们的请求资源，如果在响应头部看见Etag和Expires字段，就说明我们的缓存配置成功了。

![配置ETag和Expires](https://user-gold-cdn.xitu.io/2018/5/28/163a4d01fe069bbc?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

【特别注意】在我们配置缓存时一定要切记，浏览器在处理用户请求时，如果命中强缓存，浏览器会直接拉取本地缓存，不会与服务器发生任何通信，也就是说，如果我们在服务器端更新了文件，并不会被浏览器得知，就无法替换失效的缓存。所以我们在构建阶段，需要为我们的静态服务器资源添加md5 hash后缀，避免资源更新而引起的前后端文件无法同步的问题。

#### 1.2 资源打包压缩

我们之前所作的浏览器缓存工作，只有在用户第二次访问我们的页面才能起到效果，如果要在用户首次打开页面就实现优良的性能，必须对资源进行优化。我们常将网络性能优化措施归结为三大方面：减少请求数、减小请求资源体积、提升网络传输速率。现在，让我们逐个击破：

结合前端工程化思想，我们在对上线文件进行自动化打包编译时，通常都需要打包工具的协助，这里我推荐webpack。

在对webpack进行上线配置时，我们要特别注意以下几点：

1. JS压缩：（这点应该算是耳熟能详了，就不多介绍了）

   ```javascript
   new webpack.optimize.UglifyJsPlugin()
   ```

2. HTML压缩：

   ```javascript
   new HtmlWebpackPlugin({
       template: __dirname + '/views/index.html',	// new 一个这个插件的实例，并传入相关的参数
       filename: '../index.html'
       minify: {
   		removeComment: true,
       	collapseWhitespace: true,
       	removeRedundantAttributes: true,
           useShortDoctype: true,
           removeEmptyAttributes: true,
           removeStyleLinkTypeAttributes: true,
           keepClosingSlash: true,
           minifyJS: true,
           minifyCSS: true,
           minifyURLs: true,
   	},
       chunksSortMode: 'dependency'
   })
   ```

   我们在使用html-webpack-plugin自动化注入JS、CSS打包HTML文件时，很少会为其添加配置项，这里我给出样例，大家直接复制即可。

   PS：这里有一个技巧，在我们书写HTML元素的src或href属性时，可以省略协议部分，这样也能简单起到节省资源的目的。

3. 提取公共资源：

   ```javascript
   new webpack.optimize.COmmonsChunkPlugin({
       name: 'vendor',
       filename: 'scripts/common/vendor-[hash:5].js'
   })
   ```

   PS：这里是webpack3的语法，在webpack4中已作更改，希望大家注意

4. 提取CSS并压缩：

   在使用webpack的过程中，我们通常会以模块的形式引入css文件，但是在上线的时候，我们还需要将这些css提取出来。并且压缩，这些看似复杂的过程只需要简单的几行配置就行：

   （PS：我们需要用到extract-text-webpack-plugin）

   ```javascript
   const ExtractTextPlugin = require('extract-text-webpack-plugin');
   module: {
       rules: [..., {
               test: /\.css$/，
               use: ExtractTextPlugin.extract({
               	fallback: 'style-loader',
               	use: {
               		loader: 'css-loader',
               		options: {
               			minimize: true
               		}
               	}
               })
   	}]
   }
   ```

5. 使用webpack3的新特性：ModuleConcatenationPlugin

   ```javascript
   new webpack.optimize.ModuleConcatenationPlugin()
   ```

如果你能按照上述五点将webpack上线配置完整配置出来，基本能将文件资源体积压缩到极致了，如有疏漏，还希望大家能加以补充。

给大家一份我的webpack上线配置文档，欢迎参考：

```javascript
//webpack.pro.js
const webpack = require('webpack')
const HtmlWebpackPlugin = require('html-webpack-plugin')
const ExtractTextPlugin = require('extract-text-webpack-plugin')
const CleanWebpackPlugin = require('clean-webpack-plugin')
const CopyWebpackPlugin = require('copy-webpack-plugin')
module.exports = {
    entry: __dirname + '/public/scripts/index.js',
    output: {
        path: __dirname + '/build/static', // 打包后的文件存放的地方
        filename: 'scripts/[name]-[hash:5].js' // 打包后输出文件的文件名,带有md5 hash戳
    },
    resolve: {
        extensions: ['.jsx', '.js']
    },
    module: {
        rules: [{
            test: /(\.jsx|\.js)$/,
            use: {
                loader: 'babel-loader'
            },
            exclude: /node_modules/ // 不进行编译的目录
        }, {
            test: /\.css$/,
            use: ExtractTextPlugin.extract({
                fallback: 'style-loader',
                use: {
                    loader: 'css-loader',
                    options: {
                        minimize: true
                    }
                }
            })
        }]
    },
    plugins: [
        new HtmlWebpackPlugin({
            template: __dirname + '/views/index.html', 
            filename: '../index.html',
            minify: {
                removeComments: true,
                collapseWhitespace: true,
                removeRedundantAttributes: true,
                useShortDoctype: true,
                removeEmptyAttributes: true,
                removeStyleLinkTypeAttributes: true,
                keepClosingSlash: true,
                minifyJS: true,
                minifyCSS: true,
                minifyURLs: true,
            },
            chunksSortMode: 'dependency'
        }),
        new ExtractTextPlugin('styles/style-[hash:5].css'),
        new CleanWebpackPlugin('build/*', {
            root: __dirname,
            verbose: true,
            dry: false
        }),
        new webpack.optimize.UglifyJsPlugin(),
        new CopyWebpackPlugin([{
            from: __dirname + '/public/images',
            to: __dirname + '/build/static/images'
        }, {
            from: __dirname + '/public/scripts/vector.js',
            to: __dirname + '/build/static/scripts/vector.js'
        }]),
        new webpack.optimize.ModuleConcatenationPlugin(),
        new webpack.optimize.CommonsChunkPlugin({
            name: 'vendor',
            filename: 'scripts/common/vendor-[hash:5].js'
        })
    ]
}
```

最后，我们还应该在服务器上开启Gzip传输压缩，它能将我们的文本类文件体积压缩至原先的四分之一，效果立竿见影，还是切换到我们的nginx配置文档，添加如下两项配置项目：

```bash
gzip on;
gzip_types text/plain application/javascriptapplication/x-javascripttext/css application/xml text/javascriptapplication/x-httpd-php application/vnd.ms-fontobject font/ttf font/opentype font/x-woff image/svg+xml;
```

如果你在网站请求的响应头里看到这样的字段，那么就说明咱们的Gzip压缩配置成功了。

![Gzip压缩的配置](https://user-gold-cdn.xitu.io/2018/5/28/163a4d01fde01d06?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

【特别注意】不要读图片文件进行Gzip压缩，效果只会适得其反，至于具体原因，还得考虑服务器要锁过程中的CPU占用还有压缩率等指标，对图片进行压缩不但会占用后台大量资源（图片本身就是按照特定编码压缩过的），压缩效果其实并不可观，可以说是“弊大于利”，所以请再gzip_types把图片的相关项去掉。针对图片的相关处理，我们接下来会更加具体地介绍。

#### 1.3 图片资源优化

刚刚我们介绍了资源打包压缩，只是提留在了代码层面，而在我们实际开发中，真正占用了大量网络传输资源的，并不是这些文件，而是图片，如果你对图片进行了优化工作，你能立刻看见明细的效果。

##### 1.3.1 不要在HTML里缩放图像

很多开发者可能会有这样的错觉，比如我们会为了方便在一个200x200的图片容器内直接使用一张400x400的图片，我们甚至以为这样能让用户觉得图片更加清晰，其实不然，在普通的显示器上，用户并不会感到缩放后的大图更加清晰，但这一切却导致网页速度下降，同时造成带宽浪费，你可能不知道，一张200kb的图片和2M的图片的传输时间会是200ms和12s的差距。所以，当你需要用多大的图片时，就在服务器上准备多大的图片，尽量固定图片尺寸。



