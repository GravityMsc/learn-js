我们用websocket来研究一下TCP/IP协议的一些特性，在上一篇文章《[https连接的前几毫秒发生了什么](https://fed.renren.com/2017/02/03/https/)》里我们已经研究了https建立的过程。

上一篇是用的WireShark的抓包工具，这一片将用tcpdump命令行工具。

## 1、tcpdump

Linux系的系统有一个很好用的抓包工具，叫tcpdump，可以用来抓取网络上的tcp包，例如我要抓取8080端口的包，可以执行以下命令：

sudo tcpdump port 8080 -n

-n的意思是端口号用数字表示，还可以加上-v -vv显示更详细的信息

sudo tcpdump port 8080 -n -v

再如我要抓取来自特定源IP和发往特定目的IP的包，可以用以下命令：

sudo tcpdump src host 10.2.200.11 or dst host 10.2.200.11

指定src host和dst host，并用or/and做条件的交集和并集。

在建立一个网页的WebSocket之间先要建立一个http连接，为此我们简单写一个小demo。

## 2、hello，world的http连接

（1）首先写以下的html文件：

![html](http://fed.renren.com/wp-content/uploads/2017/05/1-5.png)

（2）然后再装一个http-server的node包，监听在8080端口，如下所示：

![监听8080](http://fed.renren.com/wp-content/uploads/2017/05/2-3.png)

（3）电脑开tcpdump命令，抓取通过8080端口通讯的包：

sudo tcpdump port 8080 -n

（4）用手机访问：http://10.2.200.140.8080，tcpdump就会打印出所有传输的tcp包，如下图所示。

![tcp包](http://fed.renren.com/wp-content/uploads/2017/05/3-2.png)

我们拿它打印的这些TCP报文做一个研究。在建立一个http连接之前，先要建立一个TCP连接，即上图的头3个报文。下面研究一下这个HTTP连接是怎么进行的。

## 3、一个完整的HTTP连接

（1）TCP三次握手

第一个报文：11 -> 140

> 10:11:06.151830 IP 10.2.200.11.63826 > 10.2.200.140.8080: **Flags [S]**, seq 2153742604, win 65535, options [mss 1460,nop,**wscale 5**,nop,nop,TS val 298297187 ecr 0,sackOK,eol], length 0

在10点11分的时候，IP为10.2.200.11（以后简称11）的63826端口向IP为10.2.200.140（以后简称140）的8080端口发了一个TCP的包，带上了标志位SYN，表示要建立一个连接，并指明包开始的序列号seq（单位为字节），以后传送的字节编号都是以这个作为起点，并告知能接收的最大报文段长度为mss为1460，一般mss都为1460.

第二个报文：140 -> 11

> 10:11:06.151917 IP 10.2.200.140.8080 > 10.2.200.11.63826: **Flags [S.]**, seq 1007874094, ack 2153742605, win 65535, options [mss 1460,nop,**wscale 5**,nop,nop,TS val 493556398 ecr 298297187,sackOK,eol], length 0

在过了87微秒之后，140进行了回复，发送了一个SYN + ACK的报文段，表示同意和11建立连接。

第三个报文：11 -> 140

> 10:11:06.190376 IP 10.2.200.11.63826 > 10.2.200.140.8080: **Flags [.]**, ack 1, **win 4117**, options [nop,nop,TS val 298297310 ecr 493556398], length 0

11收到SYN之后向140发送了一个ACK，同时改变接收窗口为4117 * 2 ^ 5 = 131kb，完成三次握手。

什么是接收窗口呢？

（2）接收窗口

第四个报文里面，140也向11修改了它的接收窗口大小：

> 10:11:06.190422 IP 10.2.200.140.8080 > 10.2.200.11.63826: Flags [.], ack 1, **win 4117**, options [nop,nop,TS val 493556436 ecr 298297310], length 0

大小为4117 * 2 ^ 5 = 131kb，为什么接收窗口是这个数呢？因为如下TCP的报文（头）：

![TCP报文头部](http://fed.renren.com/wp-content/uploads/2017/05/tcp-header.png)

窗口大小只有2个字节16位，最大只能表示2 ^ 16 - 1 = 65535即16kb，当初设计TCP的人并没有想到现在的网速会提升这么快，16kb是不够用的，所以在可选项里面加了一个wscale(window scale factor)的指数字段，最大值为14，所以最大的接收窗口大概为1GB。

说了这么多，接收窗口是用来做什么的呢？它根据自身网络情况设置不同大小的值用来控制对方发送速度，避免对方发送太快，导致网络拥塞。下面讲到拥塞控制会更进一步地讨论。

（3）发送数据

建立好TCP连接后，11向140发送了一个http请求：

> 10:11:06.193435 IP 10.2.200.11.63826 > 10.2.200.140.8080: **Flags [P.]**, **seq** **1:404**, ack 1, win 4117, options [nop,nop,TS val 298297312 ecr 493556398], length 403: HTTP: GET / HTTP/1.1

这里，它带上了一个PUSH的标志位，表示它是一个比较紧急的报文，要求对方立即把数据从缓存里面发送给应用程序，不能再继续缓存了。

它发送的字节号为[1, 404)，这个数字时tcpdump显示的相对于握手的协议初始序列号显示的偏移，它是一个左闭右开的表示，所以这个报文总共发送了403个字节的数据。它是一个GET请求。

然后后140收到后给11回复了一个ACK：

> 10:11:06.193467 IP 10.2.200.140.8080 > 10.2.200.11.63826: Flags [.], **ack** **404**, win 4105, options [nop,nop,TS val 493556439 ecr 298297312], length 0

ACK 404表示期待收到第404字节的数据，也就是说前面403个字节的数据已经都确认收到。

然后140进行了http响应：

> 10:11:06.194840 IP 10.2.200.140.8080 > 10.2.200.11.63826: Flags [P.], **seq** **1:290**, ack 404, win 4105, options [nop,nop,TS val 493556440 ecr 298297312], length 289: HTTP: HTTP/1.1 200 OK
>
> 10:11:06.200295 IP 10.2.200.11.63826 > 10.2.200.140.8080: Flags [.], **ack** **290**, win 4108, options [nop,nop,TS val 298297318 ecr 493556440], length 0
>
> 10:11:06.200315 IP 10.2.200.140.8080 > 10.2.200.11.63826: Flags [P.], **seq** **290:458**, ack 404, win 4105, options [nop,nop,TS val 493556445 ecr 298297318], length 168: HTTP
>
> 10:11:06.204847 IP 10.2.200.11.63826 > 10.2.200.140.8080: Flags [.], **ack** **458**, win 4103, options [nop,nop,TS val 298297321 ecr 493556445], length 0

140总共发送了457个字节的数据，分成了两个包发送。而本地的html文件大小为：

![本地文件大小](http://fed.renren.com/wp-content/uploads/2017/05/4-4.png)

所以可以认为http报文头占用了457 - 168 = 289字节。

（4）关闭连接

第一个报文：11 -> 140 FIN

> 10:11:36.359973 IP 10.2.200.11.63826 > 10.2.200.140.8080: **Flags [F.]**, seq 404, ack 458, win 4103, options [nop,nop,TS val 298327416 ecr 493556445], length 0

11等了30s后觉得不用再请求数据了，于是要把连接关闭了，它向140发送了一个FIN的报文。为什么要等30s才关闭呢？这是HTTP请求的Connection: keep-alive字段影响的，因为同一个域可能要请求多个资源，不能一个请求完了就把连接关闭了。如果不关闭又占用端口号资源，我们知道端口号最多只有65535个。

第二个报文：140 -> 11 ACK

> 10:11:36.360021 IP 10.2.200.140.8080 > 10.2.200.11.63826: **Flags [.]**, ack 405, win 4105, options [nop,nop,TS val 493586567 ecr 298327416], length 0

140收到这个包后向11发送一个ACK，这个时候连接处于半关闭状态，即11不可再向140发送数据了，但140还可以向11发送。

第三个报文：140 -> 11 FIN

> 10:11:36.360537 IP 10.2.200.140.8080 > 10.2.200.11.63826: **Flags [F.]**, seq 458, ack 405, win 4105, options [nop,nop,TS val 493586567 ecr 298327416], length 0

140也要把连接关闭了，于是它向11发送FIN

第四个报文：11 -> 140 ACK

> 10:11:36.368758 IP 10.2.200.11.63826 > 10.2.200.140.8080: **Flags [.]**, ack 459, win 4103, options [nop,nop,TS val 298327458 ecr 493586567], length 0

11收到后，向它发送了一个ACK，此时连接完全关闭。然后主动关闭方11将进入TIME_WAIT状态。

（5）MSS和TIME_WAIT

TIME_WAIT时间为2MSL，MSL的意思是maximum segment livetime，即报文段的最大生存时间，标准建议为2分钟，实际实现有的为30s。在TIME_WAIT状态下，上一次建立连接的套接字（socket）将不可再重新启用，也就是同一个网卡/IP不可再建立同样端口号的连接，如上面是10.2.200.11.63826，如果再重新创建系统将会报错。为什么要等待这个时间呢？主要是为了避免有些报文段在网络上滞留，被对方收到的时候如果刚好又启用了一个完全一样的套接字，那么就会被认为是这个连接的数据。因此为了让所有“迷路”的报文彻底消失后，才能启用相同的套接字。但是有时候你会觉得两分钟不能重新启动相同的socket，有点麻烦，所以要把它禁了，可以在创建socket的时候，指定SO_REUSEADDR的选项，这样就不用等待TIME_WAIT的时间了。

另外还有一个时间叫RTT（round trip time），即一个报文段的往返时间，可以理解为我发一个数据给你，你再回我一个ACK这个往返过程的时间，这个时间是动态计算的，在下面讲拥塞控制的时候将会提及这个时间。

接下来讨论两个问题。

## 4、为什么TCP握手要三次？

为什么不是两次、四次呢？有人说三次是建立一个可靠连接最少的次数，那么为什么不是两次呢？两次好像也可以啊，就像打电话：

> 甲：喂，你听得到吗？
>
> 乙：我听得到

然后甲就可以开始说话了。再举另外一个例子做说明，假设有三个山头：A、B、C，A山头想要联合B山头的人晚上六点去攻打C山头的人，因为如果只有一个山头的人去攻打C的话会阵亡，所以A和B需要进行握手。

![握手](http://fed.renren.com/wp-content/uploads/2017/05/5-8.png)

于是：

* A就派了只鸽子带上SYN的消息过去找B
* B收到后又派了只鸽子带上ACK + SYN的消息回复A
* A收到后又派了只鸽子带上ACK去回复B

这个就好像我们的三次握手，但是三次就够了吗？假设第三次A发的ACK B没有收到，这时候B就要犹豫了：会不会A不知道我同意了，如果A不知道我同意那么它可能不会去攻打了，然后我去了就得被灭了。由于A不知道它的回复有没有被收到，所以它可能会想到B可能会怕它不会出击，所以A也犹豫了。

但是这个例子并不是说TCP连接建立是不可靠的，实际的场景往往是只要双方确认对方都在就好了，如下：

> 甲：你活着吗？我想和你通话
>
> 乙：我活着呢，我们开始通话吧

因此最少的握手次数应该是两次，三次可以提高可靠性，四次、五次就没必要了，就会陷入上面山头攻打无限循环确认的漩涡。如下：

> 甲：你活着吗？我想和你通话
>
> 乙：我活着呢，我们开始通话吧
>
> 甲：好的

最后的“好的”可能有点多余，但是它显得比较有“人情味”。

难道两个山头通信真的没有办法解决吗？有办法，我们将在下面的拥塞控制提到。

## 5、为什么挥手要四次

分析了握手次数的原因，很容易可以知道为什么挥手要四次了。前两次挥手让连接处于半关闭状态，此时主动关闭方不可再向被动关闭方发送数据，而被动关闭方可以继续向主动关闭方发送数据。如下图所示：

![四次挥手](http://fed.renren.com/wp-content/uploads/2017/05/6-6.png)

所以四次的原因是可以有一个处于半关闭的状态。

接下来看一下四层网络协议。

## 6、四层网络协议

如下图所示，我们从发送数据的角度看四层网络协议：

![四层网络协议](http://fed.renren.com/wp-content/uploads/2017/05/7-5.png)

假设我要用HTTP发送一个文本，那么它会最后会被层层包装成这样一个报文。

![报文封装](http://fed.renren.com/wp-content/uploads/2017/05/8-5.png)

在广域网是用的IP地址进行报文转发，而到了局域网需要靠物理地址发送给对应的主机。IP是点到点，负责发送给对应的主机，而TCP是端到端，即根据端口号，负责发送给对应的应用程序。

（1）物理地址

每个网卡都有全球唯一的物理地址，路由器向同一个局域网所有主机发送收到的数据包，本机的网卡比较一下包里指明的物理地址和本机的物理地址是否一致，如果一致则接收，否则则丢弃。所以可以在局域网监听发给其他人的数据包，当然也有一些反监听的手段。

（2）网际层ARP

ARP是一个地址解析协议，当我访问10.2.200.140的时候我需要知道它的物理地址是多少，因为它已经是一个局域网的IP地址了。我怎么知道它的物理地址是多少呢？我就向局域网的机器广播一个ARP请求：

> 09:51:32.966852 **ARP, Request** who-has 10.2.200.140 tell 10.2.200.11, length 28

过了33微秒一小会的功夫就有人告诉我了：

> 09:51:32.966885 **ARP, Reply** 10.2.200.140 is-at 98:5a:eb:89:a5:7e (oui Unknown), length 28

这个很可能是路由器告诉我的，上面的tcpdump输出没有打印源IP。

可以通过arp -an的命令，查看电脑上的arp表，如下图所示：

![arp表](http://fed.renren.com/wp-content/uploads/2017/05/3-4.png)

（3）网际层traceroute

有一个很好用的命令叫traceroute，它可以追踪路由路径，它的原理是向目的主机发送ICMP报文，发送第一个报文时，设置TTL为0，TTL就Time to Live，是报文的生存时间，由于它是0，所以下一个路由器收到这个报文后，不会再继续转发了，会给源主机发送ICMP出错的报文，就可以知道第一个路由的IP地址，同理，设置TTL为1，就可以知道第二个路由的IP地址，依次类推。

如在北京traceroute广东电信，运行命令：

> \>traceroute gd.189.cn

控制台将不断地打印经过的路由，traceroute每次都会发三个报文：

![traceroute报文](http://fed.renren.com/wp-content/uploads/2017/05/4-3.png)

可以看到为了到广东电信官网的服务器，经过了这么一个过程——首先发给了直接路由器进行转发，然后又在局域网的路由转发了几次，最后出来到了北京联通，中间又经过了北京电信和上海电信的路由器，最后到了广州电信的路由器。我们会发现每次走的路由器可能会不一样，它是活的。这里又涉及到路由转发，本文不继续探讨。

每个报文都有一个TTL醉倒跳数，每经过一个路由就会把它减1，当减到0的时候，就不再继续转发了。避免某些报文被无限循环转发，造成网络资源的浪费。TTL位于IP报文的第9个字节。

（3）网际层ping

另外一个很常用的命令是Ping，如Ping一下127.0.0.1可以看一下本机的网络协议是否工作正常，Ping一下某个服务器，看这个服务器有没有开，Ping一下某个域名，看它的IP地址是多少。Ping还可以这么用，例如Ping一下baidu：

![ping](http://fed.renren.com/wp-content/uploads/2017/05/5-9.png)

可以看到要到百度服务器中间经过了64-49 = 15跳，所以可推测百度用的是Linux服务器，为什么呢，因为Linux的默认的最大TTL = 64，而49和64最为接近。

Ping一下美国亚马逊：

![Ping](http://fed.renren.com/wp-content/uploads/2017/05/6-7.png)

到美国亚马逊，经过了255 - 217 = 38跳，所以推测亚马逊用的Unix服务器，Unix服务器默认的最大TTL为255。

在Ping一下中国版的w3school：

![ping w3school](http://fed.renren.com/wp-content/uploads/2017/05/7-4.png)

到中国版的w3school用了128 - 107 = 21跳，Windows的默认最大跳数位128，所以w3school用的是windows操作系统，因为它用的是ASP，所以它必定是windows系统。

继续回到demo实验的讨论，下面分析一些异常的情况。

## 7、Reset报文

假设现在我把8080端口的http-server给杀了，然后再访问，会怎么样呢？会抓取到以下报文：

> 11:38:09.120488 IP 10.2.200.11.57049 > 10.2.200.140.8080: **Flags [S]**, seq 1663158265, win 65535, options [mss 1460,nop,wscale 5,nop,nop,TS val 822068310 ecr 0,sackOK,eol], length 0
>
> 11:38:09.120524 IP 10.2.200.140.8080 > 10.2.200.11.57049: **Flags [R.]**, seq 0, ack 1663158266, win 0, length 0

第一个报文还是SYN的报文，但是第二个报文服务器直接返回了RST，告诉对方不可建立连接。服务返回异常RST报文可能有以下原因：

1. 服务器没有开启服务
2. 请求超时
3. 服务程序突然挂了
4. 在一个已关闭的socket上收到数据

## 8、拥塞控制

现在我要上传一个文件，观察报文发送的情况，如下图所示：

![报文发送](http://fed.renren.com/wp-content/uploads/2017/05/8-6.png)

上面0.70s的时间内，发送了1448 * 9 = 17k的数据（MSS 1460）

这个时候突然网卡了，又会怎么样呢？如下图所示：

![网络拥堵](http://fed.renren.com/wp-content/uploads/2017/05/9-7.png)

上面1.45s的时间内，总共发送了9个包，5kb的数据。

正常情况经常一次连续发送 1448 * 6 = 8kb的数据，网卡即带宽下降的时候是如何控制发送速度的呢？先来看一下什么是接收窗口和拥塞窗口。

（1）接收窗口和拥塞窗口

在上传的过程中，服务器可能会不断地调整它的接收窗口大小：

> 14:03:38.479417 IP ec2-54-153-103-33.us-west-1.compute.amazonaws.com.https > 10.2.200.140.56342: Flags [.], ack 59651, **win 850**, options [nop,nop,TS val 954992962 ecr 598512063,nop,nop,sack 1 {61099:62547}], length 0

如收到上面的ACK报文后，服务器的接收窗口rwnd为：

rwnd = 850 * 2 ^ 5 = 27200B

我本机自己有一个拥塞创建cwnd，这个窗口用来控制我的发送速度，避免网络拥塞，这个拥塞窗口也是动态变化的，下面会提到。实际的发送窗口大小为：

发送窗口 = min(cwnd, rwnd)

当cwnd > rwnd的时候是对方的接收能力限制了我的发送速度，而当rwnd > cwnd的时候，是我的网络情况造成了发送比较慢的情况。

发送窗口又是如何决定发送速度的呢：

（2）发送窗口

假设现在要发送hello，world这个文本，已经知道发送窗口为5B，最大报文段MSS减掉报文头占用的空间之后还剩下2B，那么发送如下图所示：

![发送窗口](http://fed.renren.com/wp-content/uploads/2017/05/9-6.png)

当我收到ACK报文之后，如ACK:3，那么就可以将我的发送窗口向右移动两个字节，然后继续发送发送窗口里未发送的报文，如下图所示：

![发送窗口中未发送的报文](http://fed.renren.com/wp-content/uploads/2017/05/10-5.png)

如果没有收到对方的ACK，那么发送窗口将不可向右移动，也就是说不会发送了，如果ACK回复得慢，或者发送窗口本身比较小，那么发送的速度就没那么快了。这就是发送窗口控制发送速度的原理。当对方的带宽下降时，它减少它的接收窗口来控制我的发送速度，而当我的网卡的时候我减少我的拥塞窗口控制发送速度。

但是怎么知道网卡了呢？

（3）慢启动和拥塞避免

由于建立连接后，发送方不知道当前的网络情况怎么样， 所以它会非常地谨慎，先慢慢地发，如果对方的ACK回复的很及时，那么说明可以继续加大发送的量，并且指数位地增加，这个就是慢启动。如下访问一个Linux服务器的网址：

![慢启动](http://fed.renren.com/wp-content/uploads/2017/05/10-6.png)

可以看到，服务在收到一个GET请求后进行响应，第一次同时只发3个包，并且从时间间隔上我们可以肯定它是故意的。也就是说它是一个慢启动，为什么第一次是3个呢，因为Linux2的系统的初始化拥塞窗口initcwnd为3MSS，3MSS说明第一次只能发3个包（每个包不能超过最大报文段的长度），不同操作系统的initcwnd值如下所示，[参考](https://www.cdnplanet.com/blog/tune-tcp-initcwnd-for-optimum-performance/)：

![initcwnd](http://fed.renren.com/wp-content/uploads/2017/05/11-5.png)

Linux3据说是因为接受了谷歌的建议，所以改成了10MSS。

具体慢启动的过程如下图表所示：

![慢启动的过程](http://fed.renren.com/wp-content/uploads/2017/05/12-2.png)

拥塞窗口会以指数倍增长，一直增长到拥塞阈值ssthresh，假设这个值为192。然后再以递增的方式增加拥塞窗口，这个阶段叫拥塞避免。也就是说当cwnd < ssthresh时是慢启动的过程，而当cwnd > ssthresh时是拥塞避免。一直增长到合适的带宽大小。

在慢启动和拥塞避免过程中，可能会遇到网络拥塞的情况，造成丢包的情况，具体表现为很长时间没有收到对方的ACK，或者收到重复的ACK。