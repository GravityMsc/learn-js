上次遇到一个奇怪的问题：JS的(2.55).toFixed(1)输出的是2.5，而不是四舍五入的2.6，这是为什么呢？

进一步观察：

![JS的舍入问题](https://user-gold-cdn.xitu.io/2017/11/20/15fd7517d3e28a6c?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

发现，并不是所有的都不正常，1.55的舍入还是对的，为什么2.55、3.55就不对呢？

这个需要我们在源码里面找答案。

数字在V8里面的存储有两种类型，一种是小整数用Smi，另一种是除了小整数外的所有书，用HeapNumber，Smi是直接放在栈上的，而HeapNumber是需要new申请内存的，放在堆里面。我们可以简单地画一下堆和栈在内存的位置。

![堆和栈在内存的位置](https://user-gold-cdn.xitu.io/2017/11/20/15fd51601f9a4262?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

如下代码：

```javascript
let obj = {};
```

这里定义了一个obj的变量，obj是一个指针，它是一个局部变量，是放在栈里面的。而大括号{}实例化了一个Object，这个Object需要占用的空间是在堆里申请的内存，obj指向了这个内存所在的位置。

栈和堆相比，栈的读取效率要比堆的高，因为栈里变量可以通过内存偏差得到变量的位置，如果函数入口地址减掉一个变量占用的空间（向低地址增长），就能得到那个变量在内存的位置，而堆 需要通过指针寻址，所以堆要比栈慢（不过栈的可用空间要比堆小很多）。因此局部变量如指针、数字等占用空间较小的，通常是保存在栈里的。

对于以下代码：

```javascript
let smi = 1;
```

smi是一个Number类型的数字。如果这种简单的数字也要放在堆里面，然后搞个指针指向它，那么是划不来的，无论是在存储空间或者读取效率上。所以V8搞了一个叫Smi的类，这个类是不会被实例化的，它的指针地址就是它存储的数字的值，而不是指向堆空间。因为指针本身就是一个整数，所以可以把它当成一个整数用，反过来，这个整数可以类型转化为Smi的实例指针，就可以调Smi类定义的函数了，如获取实际的整数值是多少。

如下源码的注释：

```
// Smi represents integer Numbers that can be stored in 31 bits.
// Smis are immediate which means they are NOT allocated in the heap.
// The this pointer has the following format: [31 bit signed int] 0
// For long smis it has the following format:
//     [32 bit signed int] [31 bits zero padding] 0
// Smi stands for small integer.
```

在一般系统上int为32位，使用前面的31位表示整数的值（包括正负符号），而如果是64位的话，使用前32位表示整数的值。所以32位的时候有31位来表示数据，再减去一个符号位，还剩30位，所以Smi最大整数为 2 ^ 30 - 1 = 1073741823 = 10亿，大概为10亿。

到这里你可能会有一个问题，为什么要搞这么麻烦，不直接用基础类型如int整型来存储就好了，还要搞一个Smi的类呢？这可能是因为V8里面对JS数据的表示都是继承于根类Object的（注意这里的Object不是JS的Object，JS的Object对应的是V8的JSObject），这样可以做一些通用的处理。所以小整数也要搞一个类，但是又不能实例化，所以就用了这样的方法——使用指针存储值。

大于21亿和小数是使用HeapNumber存储的，和JSObject一样，数据是存在堆里面的，HeapNumber存储的内容是一个双精度浮点数，即8个字节 = 2 words = 64位。关于双精度浮点数的存储结构我已经在《[为什么0.1 + 0.2 不等于0.3](https://fed.renren.com/2017/05/13/float-number/)》做了很详细的介绍。这里可以再简单地提一下，如源码的定义：

```javascript
static const int kMantissaBits = 52;
static const int kExponentBits = 11;
```

64位里面，尾数占了52位，而指数用了11位，还有一位是符号我。当这个双精度的空间用于表示整数的时候，是用的52位尾数的空间，因为整数是能够用二进制精确表示的，所以52位尾数再加上隐藏的整数位的1（这个确实怎么来的可参考《[为什么0.1 + 0.2 不等于0.3](https://fed.renren.com/2017/05/13/float-number/)》）能表示的最大值为2^53 - 1：

```javascript
// ES6 section 20.1.2.6 Number.MAX_SAFE_INTEGER
const double kMaxSafeInteger = 9007199254740991.0;  // 2^53-1
```

这是一个16位的整数，进而可以知道双精度浮点数的精确位数是15位，并且有90%的概率可以认为第16位是准确的。

这样我们就知道了，数在V8里面是怎么存储的。对于2.55使用的是双精度浮点数，把2.55的64位存储打印出来是这样的：

![64位的2.55](https://user-gold-cdn.xitu.io/2017/11/19/15fd500349206fc1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

对于(2.55).toFixed(1)，源码里面是怎么进行的，首先把整数位2取出来，转成字符串，然后再把小数位取出来，根据参数指定的位数进行舍入，中间再拼个小数点，就得到了四舍五入的字符串结果。

整数部分怎么取呢？2.55的尾数部分（加上隐藏的1）为数a：

1.01000110011...

它的指数位是1，所以把这个数左移一位就得到数b：

10.1000110011...

a原本是52位，左移1位就变成了53位的数，再把b右移52 - 1 = 51位就得到整数部分为二进制的10即十进制的2。再用b减掉10左移51位的值，就得到了小数的部分。这个实际的计算过程是这样的：

```javascript
// 尾数右移51位得到整数部分
uint64_t integrals = significand >> -exponent; // exponent = 1 - 52
// 尾数减掉整数部分得到小数部分
uint64_t fractionals = significand - (integrals << -exponent);
```



