DNS解析的作用是把域名解析成相应的IP地址，因为在广域网上路由器需要知道IP地址才知道把报文发给谁。DNS是Domain Name System域名系统的缩写，它是一个协议，在[RFC 1035](https://www.ietf.org/rfc/rfc1035.txt)具体描述了这个协议。具体过程如下：

![DNS示意图](https://user-gold-cdn.xitu.io/2018/1/1/160b1c7ba6ea9b9a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

这个过程看似简单，但是有几个问题：

1. 浏览器是这么知道DNS解析服务器，如上图8.8.8.8这台？
2. 一个域名可以解析成多个IP地址吗，如果只有一个IP地址，在并发量很大的情况下，那台服务器可能会爆？
3. 把域名绑了host之后，是不是就不用域名解析了，直接用本地host指定的IP地址？
4. 域名解析的有效时间为多长，即过了多久后同一域名需要再次进行解析？
5. 什么是域名解析的A记录、AAAA记录、CNAME记录？

其实域名解析和Chrome没有直接关系，即使是最简单的curl命令也需要进行域名解析，但是我们可以通过Chrome源码来看一下这个过程是怎么样的，并且回答上面的问题。

首先第一个问题，浏览器是怎么知道DNS解析服务器的，在本机的网络设置里面可以看到当前的DNS服务器IP，比如我电脑的：

![作者电脑的DNSIP](https://user-gold-cdn.xitu.io/2018/1/1/160b1c7ba762ace5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

这两个DNS Server是我家接的某正宽带提供的：

![方正宽带](https://user-gold-cdn.xitu.io/2018/1/1/160b1c7ba6c1a084?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

一般宽带服务商都会提供DNS服务器，谷歌还为公众提供了两个免费的DNS服务，分别为8.8.8.8和8.8.4.4，取这两个IP地址是为了容易记住，当你的DNS服务不好用的时候，可以尝试改成这两个。

入网的设备是怎么获取到这些IP地址的呢？是通过动态主机配置协议（DHCP），当一台设备连到路由器之后，路由器通过DHCP给它分配一个IP地址，并告诉它DNS服务器，如下路由器的DHCP配置：

![DHCP服务器的配置](https://user-gold-cdn.xitu.io/2018/1/1/160b1c7ba6edaef1?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

通过wireshark抓包可以观察到这个过程：

![wireshark抓包DHCP分配IP](https://user-gold-cdn.xitu.io/2018/1/1/160b1c7ba6d97369?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

当我的电脑连上wifi的时候，会发出一个DHCP Request的广播，路由器收到这个广播后就会向我的电脑分配一个IP地址并告知DNS服务器。

这个时候系统就有DNS服务器了，Chrome是调[res_ninit](http://man7.org/linux/man-pages/man3/resolver.3.html)这个系统函数（Linux）去获取系统的DNS服务器，这个函数是通过读取/etc/resolver.conf这个文件获取DNS：

```bash
#
# Mac OS X Notice
#
# This file is not used by the host name and address resolution
# or the DNS query routing mechanisms used by most processes on
# this Mac OS X system.
#
# This file is automatically generated.
#
search DHCP HOST
nameserver 59.108.61.61
nameserver 219.232.48.61
```

search选项的作用是当一个域名不可解析时，就会尝试在后面添加相应的后缀，如ping hello，无法解析就会分别ping hello.DHCP/hello.HOST，结果最后都无法解析。

Chrome在启动的时候根据不同的操作系统去获取DNS服务器配置，然后把它放到DNSConfig的nameservers：

```c++
  // List of name server addresses.
  std::vector<IPEndPoint> nameservers;
```

Chrome还会监听网络变化同步改变配置。

然后用nameservers列表去初始化一个socket pool即套接字池，套接字是用来发请求的。在需要做域名解析的时候会从套接字池里面取出一个socket，并传递想要用的server_index，初始化的时候是0，即去第一个DNS服务IP地址，一旦解析请求两次都失败了，即server_index + 1使用下一个DNS服务。

```c++
    unsigned server_index =
        (first_server_index_ + attempt_number) % config.nameservers.size();
    // Skip over known failed servers.
    // 最大attempts数为2，在构造DnsConfig设定的
    server_index = session_->NextGoodServerIndex(server_index);
```

如果所有的nameservers都失败了，那么它会去最早失败的nameserver。

Chrome在启动的时候除了会读取DNS Server之外，还会去读取和解析hosts文件，放到DNSConfig的hosts属性里面，它是一个哈希map：

```c++
// Parsed results of a Hosts file.
//
// Although Hosts files map IP address to a list of domain names, for name
// resolution the desired mapping direction is: domain name to IP address.
// When parsing Hosts, we apply the "first hit" rule as Windows and glibc do.
// With a Hosts file of:
// 300.300.300.300 localhost # bad ip
// 127.0.0.1 localhost
// 10.0.0.1 localhost
// The expected resolution of localhost is 127.0.0.1.
using DnsHosts = std::unordered_map<DnsHostsKey, IPAddress, DnsHostsKeyHash>;
```

hosts文件在linux系统上是在/etc/hosts：

```c++
const base::FilePath::CharType kFilePathHosts[] =
    FILE_PATH_LITERAL("/etc/hosts");
```

读取这个问题没有什么技巧，需要一行行地去处理，并做一些非法情况的判断，如上面代码的注释。

这样DNSConfig里面就有两个配置了，一个是hosts，另一个是nameservers，DNSConfig是组合到DNSSession，它们的组合关系如下图所示：

![DNSSession](https://user-gold-cdn.xitu.io/2018/1/1/160b1c7ba75fa41a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

resolver是负责解析的驱动类，它组合了一个client，client 创建了一个session，session层有一个很大的作用是用来管理server_index和socket pool如分配socket等，session初始化config，config用来读取本地绑定的hosts和nameservers两个配置。这几层各有各的职责。

resolver有一个重要的功能，它组合了一个job，用来创建任务队里。resolver还组合了一个Hostcache，它是放解析结果的缓存，如果缓存命中的话，就不用去解析了，这个过程是这样的，外部调resolver提供的HostResovlerImpl::Resolve接口，这个接口会先判断在本地是否能处理：

```c++
  int net_error = ERR_UNEXPECTED;
  if (ServeFromCache(*key, info, &net_error, addresses, allow_stale,
                     stale_info)) {
    source_net_log.AddEvent(NetLogEventType::HOST_RESOLVER_IMPL_CACHE_HIT,
                            addresses->CreateNetLogCallback());
    // |ServeFromCache()| will set |*stale_info| as needed.
    return net_error;
  }

  // TODO(szym): Do not do this if nsswitch.conf instructs not to.
  // http://crbug.com/117655
  if (ServeFromHosts(*key, info, addresses)) {
    source_net_log.AddEvent(NetLogEventType::HOST_RESOLVER_IMPL_HOSTS_HIT,
                            addresses->CreateNetLogCallback());
    MakeNotStale(stale_info);
    return OK;
  }

  return ERR_DNS_CACHE_MISS;
```

上面代码先调serverFromCache里面看有没有，如果cache命中的话则返回，否则看hosts是否命中，如果都不命中则返回CACHE_MISS的标志位。如果返回值不等于CACHE_MISS，则直接返回：

```c++
if (rv != ERR_DNS_CACHE_MISS) {
    LogFinishRequest(source_net_log, info, rv);
    RecordTotalTime(info.is_speculative(), true, base::TimeDelta());
    return rv;
  }
```

否则创建一个job，并看是否能立刻执行，如果job队列太多了，则添加到job队列后面，并传递一个成功的回调处理函数。

所以这里和我们的认知基本上是一样的，先看下cache有没有，然后再看hosts有没有，如果没有的话再进行查询。在cache查询的时候如果这个cache已经过期了即staled，也会返回null，而判断是否stale的标准如下：

```c++
 bool is_stale() const {
      return network_changes > 0 || expired_by >= base::TimeDelta();
    }
```

即网络发生了变化，或者expired_by大于0，则认为是过时的cache。这个时间差是用当时时间减去当前cache的过期时间：