前端无法像原生APP一样直接操作本地文件，否则的话打开个网页就能把用户电脑上的文件偷光了，所以需要通过用户触发，用户可通过以下三种方式操作触发：

1. 通过input type=“file”选择本地文件
2. 通过拖拽的方式把文件拖过来
3. 在编辑框里面复制粘贴

第一种是最常用的手段，通常还会自定义一个按钮，然后盖在它上面，因为type=“file”的input不好改变样式。如下代码写一个选择控件，并放在form里面：

```html
<form>
    <input type="file" id="file-input" name="fileContent">
</form>
```

然后就可以用FormData获取整个表单的内容：

```javascript
$('#file-input').on("change", function(){
    console.log(`file name is ${this.value}`);
    let formData = new FormData(this.form);
    formData.append("fileName", this.value);
    console.log(formData);
});
```

把input的value和formData打印出来是这样的：

![formData](https://user-gold-cdn.xitu.io/2017/11/25/15ff349ac0afefa0?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

可以看到文件的路径是一个假的路径，也就是说在浏览器无法获取到文件的真实存放位置。同时FormData打印出来是一个空的Object，但并不是说它的内容是空的，只是它对前端开发人员是透明的，无法查看、修改、删除里面的内容，只能append添加字段。

FormData无法得到文件的内容，而使用FileReader可以读取整个文件的内容。用户选择文件之后，input.files就可以得到用户选中的文件，如下代码：

```javascript
$("#file-input").on("change", function(){
    let fileReader = new FileReader(),
        fileType = this.files[0].type;
    fileReader.onload = function(){
        if(/^image/.test(fileType)){
            // 读取结果在FileReader.result里面
            $(`<img src="${this.result}">`).appendTo("body");
        }
    }
    // 打印原始File对象
    console.log(this.files[0]);
    // base64方式读取
    fileReader.readAsDataURL(this.files[0]);
});
```

把原始的File对象打印出来是这样的：

![FileReader对象](https://user-gold-cdn.xitu.io/2017/11/25/15ff349ac079ba68?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

它是一个window.File的实例，包含了文件的修改时间、文件名、文件的大小、文件的mime类型等。如果需要限制上传文件的大小就可以通过判断size属性有没有超，单位是字节，而需要判断是否为图片文件就可以通过type类型是否以image开头。通过判断文件名的后缀可能会不准，而通过这种判断会比较准。上面的代码使用了一个正则判断，如果是一张图片的话就把它赋值给img的src，并添加到dom里面，但其实这段代码有点问题，就是web不是所有的图片都能通过img标签展示出来，通常是jpg/png/gif这三种，所以你应该需要再判断一下图片格式，如可以把判断改成：

```javascript
/^image\/[jpg|png|gif]/.test(this.type);
```

然后实例化一个FileReader，调用它的readAsDataURL并把File对象传给它，监听它的onload事件，load完读取的结果就在它的result属性里了。它是一个base64格式的，可直接赋值给一个img的src。

使用FileReader除了可读取为base64之外，还能读取为以下格式：

```javascript
// 按base64的方式读取，结果是base64，任何文件都可转成base64的形式
fileReader.readAsDataURL(this.files[0]);

// 以二进制字符串方式读取，结果是二进制内容的utf-8形式，已被废弃了
fileReader.readASBinaryString(this.files[0]);

// 以原始二进制方式读取，读取结果可直接转成整数数组
fileReader.readAsArrayBuffer(this.files[0]);
```

其他的主要是能读取为ArrayBuffer，它是一个原始二进制格式的结果。把ArrayBuffer打印出来是这样的：

![ArrayBuffer的内容](https://user-gold-cdn.xitu.io/2017/11/25/15ff349ac05a9b42?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

可以看到，它对前端人员也是透明的，不能够直接读取里面的内容，但可以通过ArrayBuffer.length得到长度，还能转成整型数组，就能知道文件的原始二进制内容了。

```javascript
let buffer = this.result;
// 依次每字节8位读取，放到一个整数数组
let view = new Uint8Array(buffer);
console.log(view);
```

如果是通过第二种拖拽的方式，应该怎么读取文件呢？如下HTML（样式略）

```html
<div class="img-container">
    drop your image here
</div>
```

这将在页面显示一个框：

![拖拽的方式读取文件](https://user-gold-cdn.xitu.io/2017/11/25/15ff349ac1f2ebd5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

然后监听它的拖拽事件。

```javascript
$(".img-container").on("dragover", function(event){
    event.preventDefault();
}).on("drop", function(event){
    event.preventDefault();
    // 数据在event的dataTransfer对象里
    let file = event.originalEvent.dataTransfer.files[0];
    
    // 然后就可以使用FileReader进行操作
    fileReader.readAsDataURL(file);
    
    // 或者是添加到一个FormData
    let formData = new FormData();
    formData.append("fileContent", file);
});
```

数据在drop事件的event.dataTransfer.files里面，拿到这个File对象之后就可以和输入框进行一样的操作了，即使用FileReader读取，或者是新建一个空的FormData，然后把它append到FormData里面。

第三种粘贴的方式，通常是在一个编辑框里操作，如把div的contenteditable设置为true：

```html
<div contenteditable="true">
    hello, paste your image here
</div>
```

粘贴的数据时再event.clipboardData.files里面：

```javascript
$("#editor").on("paste", function(event){
    let file = event.originalEvent.clipboardData.files[0];
});
```

但是Safari粘贴不是用过event传递的，它是直接在输入框里面添加一张图片，如下图所示：

![Safari的粘贴做法](https://user-gold-cdn.xitu.io/2017/11/25/15ff349ac3330972?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

它新建了一个img标签，并把img的src指向一个blob的本地数据。什么是blob呢，如何读取blob的内容呢？

blob是一种类文件的存储格式，它可以存储几乎任何格式的内容，如json：

```javascript
let data = {hello: "world"};
let blod = new Blod([JSON.stringify(datya)], {type: 'application/json'});
```

为了获取本地的blob数据，我们可以用ajax发个本地的请求：

```javascript
$("#editor").on("paste", function(event){
    // 需要setTimeout 0等图片出来了在处理
    setTimeout(() => {
        let img = $(this).find("img[src^='blob']")[0];
        console.log(img.src);
        // 用一个xhr获取blob数据
        let xhr = new XMLHttpRequest();
        xhr.open("GET", img.src);
        // 改变mime类型
        xhr.responseType = "blob";
        xhr.onload = function (){
            // response就是一个Blob对象
            console.log(this.response);
        };
        xhr.send();
    }, 0);
});
```

上面代码把blob打印出来是这样的：

![blob打印的结果](https://user-gold-cdn.xitu.io/2017/11/25/15ff349ac408b172?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

能得到它的大小和类型，但是具体内容是不可见的，它有一个slice的方法，可用于切割大文件。和File一样，可以使用FileReader读取它的内容：

```javascript
function readBlob(blobImg){
    let fileReader = new FileReader();
    fileReader.onload = function(){
        console.log(this.result);
    };
    fileReader.onerror = function(err){
        console.log(err);
    };
    fileReader.readAsDataURL(blobImg);
}

readBlob(this.response);
```

除此之外，还能使用window.URL读取，这是一个新的API，经常和Service Worker配套使用，因为SW里面常常要解析url。如下代码：

```javascript
function readBlob(blobImg){
    let urlCreator = window.URL || window.webkitURL;
    // 得到base64的结果
    let imageUrl = urlCreator.createObjectURL(this.response);
    return imageUrl;
}

readBlob(this.response);
```

关于src使用的是blob链接的，除了上面提到的img之外，另外一个很常见的是video标签，如youtobe的视频就是使用的blob：

![youtobe的视频](https://user-gold-cdn.xitu.io/2017/11/25/15ff349af40951d9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

这种数据不是直接在本地的，而是通过持续请求视频数据，然后再通过blob这个容器媒介添加到video里面，它也是通过URL对的API创建的：

```javascript
let mediaSource = new MediaSource();
video.src = URL.createObjectURL(mediaSource);
let sourceBuffer = mediaSource.addSourceBuffer('video/mp4' codecs="avc1.42E01E, mp4a.40.2"');
sourceBuffer.appendBuffer(buf);
```

具体我也没实践过，不再展开讨论。

上面，我们使用了三种方式获取文件内容，最后得到：

1. FormData格式
2. FileReader读取得到的base63或者ArrayBuffer二进制格式

如果直接就是一个FormData了，那么直接用ajax发出去就行了，不用做任何处理。

```javascript
let form = document.querySelector("form"),
    formData = new FormData(form);
formData.append("fileName", "photo.png");

let xhr = new XMLHttpRequest();
// 假设上传文件的接口叫upload
xhr.open("POST", "/upload");
xhr.send(formData);
```

